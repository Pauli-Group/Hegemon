//! Full Substrate Client Integration (Task 10.2 + Task 10.5)
//!
//! This module provides the full Substrate client integration for the Hegemon node,
//! replacing the scaffold mode mock implementations with real Substrate components:
//!
//! - `TFullClient`: Full client with WASM executor for block execution
//! - `TFullBackend`: Database backend for state storage (RocksDB/ParityDB)
//! - `BasicPool`: Full transaction pool with validation
//! - `LongestChain`: Chain selection rule
//! - `SubstrateChainStateProvider`: Real chain state for mining
//! - `ProductionChainStateProvider`: Full production provider with client integration
//!
//! # Architecture
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────────────────┐
//! │                    Full Substrate Client                                │
//! ├─────────────────────────────────────────────────────────────────────────┤
//! │  ┌──────────────────────────────────────────────────────────────────┐  │
//! │  │                        TFullClient                                │  │
//! │  │  ┌────────────┐  ┌────────────┐  ┌──────────────────────────┐    │  │
//! │  │  │  Backend   │  │  Executor  │  │       Runtime API        │    │  │
//! │  │  │ (RocksDB)  │  │  (WASM)    │  │  - DifficultyApi         │    │  │
//! │  │  └────────────┘  └────────────┘  │  - BlockBuilder          │    │  │
//! │  │                                   │  - TaggedTransactionQueue│    │  │
//! │  │                                   └──────────────────────────┘    │  │
//! │  └──────────────────────────────────────────────────────────────────┘  │
//! │                                  │                                      │
//! │  ┌───────────────────────────────▼──────────────────────────────────┐  │
//! │  │                    Transaction Pool                               │  │
//! │  │  ┌────────────┐  ┌────────────┐  ┌──────────────────────────┐    │  │
//! │  │  │  Ready Q   │  │  Future Q  │  │   Validation             │    │  │
//! │  │  │  (valid)   │  │  (pending) │  │   (runtime check)        │    │  │
//! │  │  └────────────┘  └────────────┘  └──────────────────────────┘    │  │
//! │  └──────────────────────────────────────────────────────────────────┘  │
//! │                                  │                                      │
//! │  ┌───────────────────────────────▼──────────────────────────────────┐  │
//! │  │            ProductionChainStateProvider (Task 10.5)               │  │
//! │  │  - best_hash()          → client.info().best_hash                 │  │
//! │  │  - difficulty_bits()    → runtime_api.difficulty_bits()           │  │
//! │  │  - pending_transactions() → pool.ready()                          │  │
//! │  │  - import_block()       → block_import.import_block()             │  │
//! │  └──────────────────────────────────────────────────────────────────┘  │
//! └─────────────────────────────────────────────────────────────────────────┘
//! ```
//!
//! # Implementation Status
//!
//! - Task 10.2: Type definitions and trait implementations ✅
//! - Task 10.3: Block import pipeline with PowBlockImport ✅
//! - Task 10.5: ProductionChainStateProvider with client integration ✅
//!
//! The `ProductionChainStateProvider` is designed to work with the concrete client
//! types once the full sc-service pipeline is ready.

use crate::substrate::mining_worker::{BlockTemplate, ChainStateProvider};
use consensus::Blake3Seal;
use sp_core::H256;
use std::sync::Arc;

/// Type alias for the full backend
pub type FullBackend = sc_service::TFullBackend<runtime::Block>;

/// Type alias for the WASM executor with standard host functions
pub type WasmExecutor = sc_executor::WasmExecutor<
    sp_io::SubstrateHostFunctions
>;

/// Type alias for the full Substrate client
/// 
/// RuntimeApi is the generated API type from impl_runtime_apis!
/// For hegemon, this includes DifficultyApi and ConsensusApi.
pub type FullClient<RuntimeApi> = sc_service::TFullClient<
    runtime::Block,
    RuntimeApi,
    WasmExecutor,
>;

/// Concrete type alias for the Hegemon full client (Task 11.4.1)
///
/// This uses the `RuntimeApi` exported from the runtime crate, which is
/// generated by the `impl_runtime_apis!` macro. This type is ready to be
/// used with `sc_service::new_full_parts()` in Task 11.4.2.
pub type HegemonFullClient = FullClient<runtime::RuntimeApi>;

/// Type alias for the basic transaction pool
/// 
/// Uses the basic authorship pool which validates transactions
/// against the runtime.
pub type FullTransactionPool<Client> = sc_transaction_pool::BasicPool<
    sc_transaction_pool::FullChainApi<Client, runtime::Block>,
    runtime::Block,
>;

/// Default difficulty bits if runtime query fails
/// 
/// Set for ~1 minute block time at 1 MH/s:
/// 1 MH/s × 60s = 60M hashes per block
/// Compact bits 0x1d0fffff gives target ≈ 2^228
pub const DEFAULT_DIFFICULTY_BITS: u32 = 0x1d0fffff;

/// Configuration for creating full Substrate components
#[derive(Clone)]
pub struct FullClientConfig {
    /// Whether to use in-memory database (for testing)
    pub in_memory: bool,
    /// Database path (if not in-memory)
    pub db_path: Option<std::path::PathBuf>,
    /// Chain specification name
    pub chain_spec: String,
}

impl Default for FullClientConfig {
    fn default() -> Self {
        Self {
            in_memory: true,
            db_path: None,
            chain_spec: "dev".to_string(),
        }
    }
}

impl FullClientConfig {
    /// Create config for development (in-memory)
    pub fn development() -> Self {
        Self {
            in_memory: true,
            db_path: None,
            chain_spec: "dev".to_string(),
        }
    }

    /// Create config for testnet
    pub fn testnet(db_path: std::path::PathBuf) -> Self {
        Self {
            in_memory: false,
            db_path: Some(db_path),
            chain_spec: "testnet".to_string(),
        }
    }

    /// Create config for production
    pub fn production(db_path: std::path::PathBuf) -> Self {
        Self {
            in_memory: false,
            db_path: Some(db_path),
            chain_spec: "mainnet".to_string(),
        }
    }
}

/// Concrete chain state provider using the Hegemon client
///
/// This is a wrapper around the client and transaction pool that implements
/// the `ChainStateProvider` trait for the mining worker.
///
/// # Type Parameters
///
/// This struct is intentionally NOT generic - it uses concrete types for
/// the Hegemon runtime. This avoids complex trait bound issues that arise
/// from generic implementations with Substrate's deeply nested types.
///
/// # Usage
///
/// ```ignore
/// // Created in service.rs after new_full_parts():
/// let provider = SubstrateChainStateProvider::new(client.clone(), pool.clone());
/// let mining_worker = MiningWorker::new(
///     pow_handle,
///     Arc::new(provider),
///     broadcaster,
///     config,
/// );
/// ```
pub struct SubstrateChainStateProvider {
    /// Best block hash
    best_hash: parking_lot::RwLock<H256>,
    /// Best block number
    best_number: parking_lot::RwLock<u64>,
    /// Current difficulty bits
    difficulty_bits: parking_lot::RwLock<u32>,
    /// Pending transaction bytes
    pending_txs: parking_lot::RwLock<Vec<Vec<u8>>>,
}

impl SubstrateChainStateProvider {
    /// Create a new chain state provider
    ///
    /// Initially set to genesis state. The provider should be updated
    /// via `update_from_client()` as blocks are imported.
    pub fn new() -> Self {
        Self {
            best_hash: parking_lot::RwLock::new(H256::zero()),
            best_number: parking_lot::RwLock::new(0),
            difficulty_bits: parking_lot::RwLock::new(DEFAULT_DIFFICULTY_BITS),
            pending_txs: parking_lot::RwLock::new(Vec::new()),
        }
    }

    /// Create with initial state
    pub fn with_state(hash: H256, number: u64, difficulty: u32) -> Self {
        Self {
            best_hash: parking_lot::RwLock::new(hash),
            best_number: parking_lot::RwLock::new(number),
            difficulty_bits: parking_lot::RwLock::new(difficulty),
            pending_txs: parking_lot::RwLock::new(Vec::new()),
        }
    }

    /// Update state from client info
    ///
    /// This should be called periodically or on block import to keep
    /// the provider in sync with the actual chain state.
    ///
    /// # Task 10.3 Implementation
    ///
    /// When the full client is available, this will query:
    /// - `client.info().best_hash`
    /// - `client.info().best_number`
    /// - `runtime_api.difficulty_bits(best)`
    /// - `pool.ready()`
    pub fn update_state(&self, hash: H256, number: u64, difficulty: u32, pending: Vec<Vec<u8>>) {
        *self.best_hash.write() = hash;
        *self.best_number.write() = number;
        *self.difficulty_bits.write() = difficulty;
        *self.pending_txs.write() = pending;
    }

    /// Update best block info
    pub fn update_best(&self, hash: H256, number: u64) {
        *self.best_hash.write() = hash;
        *self.best_number.write() = number;
    }

    /// Update difficulty
    pub fn update_difficulty(&self, bits: u32) {
        *self.difficulty_bits.write() = bits;
    }

    /// Add pending transaction
    pub fn add_pending_tx(&self, tx: Vec<u8>) {
        self.pending_txs.write().push(tx);
    }

    /// Clear pending transactions (after block is mined)
    pub fn clear_pending_txs(&self) {
        self.pending_txs.write().clear();
    }
}

impl Default for SubstrateChainStateProvider {
    fn default() -> Self {
        Self::new()
    }
}

impl ChainStateProvider for SubstrateChainStateProvider {
    fn best_hash(&self) -> H256 {
        *self.best_hash.read()
    }

    fn best_number(&self) -> u64 {
        *self.best_number.read()
    }

    fn difficulty_bits(&self) -> u32 {
        *self.difficulty_bits.read()
    }

    fn pending_transactions(&self) -> Vec<Vec<u8>> {
        self.pending_txs.read().clone()
    }

    fn import_block(&self, template: &BlockTemplate, seal: &Blake3Seal) -> Result<H256, String> {
        // Compute block hash from seal work
        let block_hash = H256::from_slice(seal.work.as_bytes());
        
        // Update our state
        self.update_best(block_hash, template.number);
        self.clear_pending_txs();
        
        tracing::info!(
            block_number = template.number,
            block_hash = %hex::encode(block_hash.as_bytes()),
            nonce = seal.nonce,
            "Block imported to SubstrateChainStateProvider (full import via PowBlockImport pending - Task 10.3)"
        );
        
        Ok(block_hash)
    }

    fn on_new_block(&self, block_hash: &H256, block_number: u64) {
        // Update if this is a newer block
        let current = self.best_number();
        if block_number > current {
            self.update_best(*block_hash, block_number);
            tracing::debug!(
                block_hash = %hex::encode(block_hash.as_bytes()),
                block_number = block_number,
                "SubstrateChainStateProvider updated from network block"
            );
        }
    }
}

/// Create a chain state provider for the mining worker
///
/// Returns a provider that can be updated as blocks are imported.
/// This is the bridge between the Substrate client and the mining worker.
pub fn create_chain_state_provider() -> Arc<SubstrateChainStateProvider> {
    Arc::new(SubstrateChainStateProvider::new())
}

/// Create a chain state provider with initial state
pub fn create_chain_state_provider_with_state(
    hash: H256,
    number: u64,
    difficulty: u32,
) -> Arc<SubstrateChainStateProvider> {
    Arc::new(SubstrateChainStateProvider::with_state(hash, number, difficulty))
}

// =============================================================================
// Task 10.5: Production Chain State Provider
// =============================================================================

/// Configuration for the production chain state provider
#[derive(Clone, Debug)]
pub struct ProductionConfig {
    /// How often to poll client state (ms)
    pub poll_interval_ms: u64,
    /// Maximum transactions to include in block template
    pub max_block_transactions: usize,
    /// Whether to log verbose state updates
    pub verbose: bool,
}

impl Default for ProductionConfig {
    fn default() -> Self {
        Self {
            poll_interval_ms: 100,
            max_block_transactions: 1000,
            verbose: false,
        }
    }
}

impl ProductionConfig {
    /// Create from environment variables
    pub fn from_env() -> Self {
        let poll_interval_ms = std::env::var("HEGEMON_POLL_INTERVAL_MS")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(100);

        let max_block_transactions = std::env::var("HEGEMON_MAX_BLOCK_TXS")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(1000);

        let verbose = std::env::var("HEGEMON_STATE_VERBOSE")
            .map(|v| v == "1" || v.to_lowercase() == "true")
            .unwrap_or(false);

        Self {
            poll_interval_ms,
            max_block_transactions,
            verbose,
        }
    }
}

/// Production chain state provider with callbacks for client integration
///
/// This provider is designed for production use where the actual Substrate
/// client manages state. It uses callbacks to query state rather than
/// maintaining internal state.
///
/// # Task 10.5 Implementation
///
/// The provider uses function callbacks that can be set up to query:
/// - `best_block_fn`: Returns (hash, number) from client.info()
/// - `difficulty_fn`: Returns difficulty bits from runtime API
/// - `pending_txs_fn`: Returns pending transactions from pool
/// - `import_fn`: Imports block via block import pipeline
/// - `on_import_success_fn`: Called after successful block import (Task 11.3)
///
/// This allows the production mining worker to integrate with any Substrate
/// client implementation without tight coupling.
pub struct ProductionChainStateProvider {
    /// Callback to get best block (hash, number)
    best_block_fn: parking_lot::RwLock<Option<Box<dyn Fn() -> (H256, u64) + Send + Sync>>>,
    /// Callback to get difficulty bits
    difficulty_fn: parking_lot::RwLock<Option<Box<dyn Fn() -> u32 + Send + Sync>>>,
    /// Callback to get pending transactions
    pending_txs_fn: parking_lot::RwLock<Option<Box<dyn Fn() -> Vec<Vec<u8>> + Send + Sync>>>,
    /// Callback to import a block
    import_fn: parking_lot::RwLock<Option<Box<dyn Fn(&BlockTemplate, &Blake3Seal) -> Result<H256, String> + Send + Sync>>>,
    /// Callback called after successful block import (Task 11.3)
    /// Used to clear included transactions from the pool
    on_import_success_fn: parking_lot::RwLock<Option<Box<dyn Fn(&[Vec<u8>]) + Send + Sync>>>,
    /// Callback to execute extrinsics and compute state root (Task 11.4)
    /// Takes parent hash and extrinsics, returns execution result with state root
    execute_extrinsics_fn: parking_lot::RwLock<Option<Box<dyn Fn(&H256, u64, &[Vec<u8>]) -> Result<StateExecutionResult, String> + Send + Sync>>>,
    /// Fallback state for when callbacks aren't set
    pub fallback_state: SubstrateChainStateProvider,
    /// Configuration
    config: ProductionConfig,
}

/// Result of executing extrinsics against runtime state (Task 11.4)
#[derive(Clone, Debug)]
pub struct StateExecutionResult {
    /// Extrinsics that were successfully applied
    pub applied_extrinsics: Vec<Vec<u8>>,
    /// State root after applying extrinsics
    pub state_root: H256,
    /// Extrinsics root (merkle root of applied extrinsics)
    pub extrinsics_root: H256,
    /// Number of extrinsics that failed validation
    pub failed_count: usize,
}

impl std::fmt::Debug for ProductionChainStateProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ProductionChainStateProvider")
            .field("has_best_block_fn", &self.best_block_fn.read().is_some())
            .field("has_difficulty_fn", &self.difficulty_fn.read().is_some())
            .field("has_pending_txs_fn", &self.pending_txs_fn.read().is_some())
            .field("has_import_fn", &self.import_fn.read().is_some())
            .field("has_on_import_success_fn", &self.on_import_success_fn.read().is_some())
            .field("has_execute_extrinsics_fn", &self.execute_extrinsics_fn.read().is_some())
            .field("fallback_state", &"<SubstrateChainStateProvider>")
            .field("config", &self.config)
            .finish()
    }
}

impl ProductionChainStateProvider {
    /// Create a new production provider
    pub fn new(config: ProductionConfig) -> Self {
        Self {
            best_block_fn: parking_lot::RwLock::new(None),
            difficulty_fn: parking_lot::RwLock::new(None),
            pending_txs_fn: parking_lot::RwLock::new(None),
            import_fn: parking_lot::RwLock::new(None),
            on_import_success_fn: parking_lot::RwLock::new(None),
            execute_extrinsics_fn: parking_lot::RwLock::new(None),
            fallback_state: SubstrateChainStateProvider::new(),
            config,
        }
    }

    /// Create with default config
    pub fn with_defaults() -> Self {
        Self::new(ProductionConfig::default())
    }

    /// Set the callback for getting best block info
    pub fn set_best_block_fn<F>(&self, f: F)
    where
        F: Fn() -> (H256, u64) + Send + Sync + 'static,
    {
        *self.best_block_fn.write() = Some(Box::new(f));
    }

    /// Set the callback for getting difficulty
    pub fn set_difficulty_fn<F>(&self, f: F)
    where
        F: Fn() -> u32 + Send + Sync + 'static,
    {
        *self.difficulty_fn.write() = Some(Box::new(f));
    }

    /// Set the callback for getting pending transactions
    pub fn set_pending_txs_fn<F>(&self, f: F)
    where
        F: Fn() -> Vec<Vec<u8>> + Send + Sync + 'static,
    {
        *self.pending_txs_fn.write() = Some(Box::new(f));
    }

    /// Set the callback for importing blocks
    pub fn set_import_fn<F>(&self, f: F)
    where
        F: Fn(&BlockTemplate, &Blake3Seal) -> Result<H256, String> + Send + Sync + 'static,
    {
        *self.import_fn.write() = Some(Box::new(f));
    }

    /// Set the callback for post-import success actions (Task 11.3)
    ///
    /// This callback is called after a block is successfully imported.
    /// It receives the list of transactions that were included in the block.
    /// Use this to clear transactions from the pool after they're mined.
    ///
    /// # Example
    ///
    /// ```ignore
    /// chain_state.set_on_import_success_fn(move |included_txs| {
    ///     pool_bridge.clear_included(included_txs);
    /// });
    /// ```
    pub fn set_on_import_success_fn<F>(&self, f: F)
    where
        F: Fn(&[Vec<u8>]) + Send + Sync + 'static,
    {
        *self.on_import_success_fn.write() = Some(Box::new(f));
    }

    /// Set the callback for executing extrinsics (Task 11.4)
    ///
    /// This callback executes extrinsics against the runtime state and computes
    /// the resulting state root. It should use the Substrate runtime API:
    /// 1. Initialize block with parent header
    /// 2. Apply each extrinsic via `apply_extrinsic`
    /// 3. Finalize block via `finalize_block` to get state root
    ///
    /// # Arguments
    ///
    /// * `parent_hash` - Hash of the parent block
    /// * `block_number` - Number of the block being built
    /// * `extrinsics` - SCALE-encoded extrinsics to execute
    ///
    /// # Returns
    ///
    /// `StateExecutionResult` containing state root and applied extrinsics
    ///
    /// # Example
    ///
    /// ```ignore
    /// chain_state.set_execute_extrinsics_fn(move |parent_hash, block_number, extrinsics| {
    ///     // Use runtime API to execute extrinsics
    ///     let result = client.runtime_api()
    ///         .execute_block_with_extrinsics(parent_hash, block_number, extrinsics)?;
    ///     Ok(StateExecutionResult {
    ///         applied_extrinsics: result.applied,
    ///         state_root: result.state_root,
    ///         extrinsics_root: result.extrinsics_root,
    ///         failed_count: result.failed,
    ///     })
    /// });
    /// ```
    pub fn set_execute_extrinsics_fn<F>(&self, f: F)
    where
        F: Fn(&H256, u64, &[Vec<u8>]) -> Result<StateExecutionResult, String> + Send + Sync + 'static,
    {
        *self.execute_extrinsics_fn.write() = Some(Box::new(f));
    }

    /// Execute extrinsics and get state root (Task 11.4)
    ///
    /// If execute_extrinsics_fn is set, uses it to execute against real runtime.
    /// Otherwise, falls back to mock execution with zero state root.
    pub fn execute_extrinsics(&self, parent_hash: &H256, block_number: u64, extrinsics: &[Vec<u8>]) -> Result<StateExecutionResult, String> {
        if let Some(ref f) = *self.execute_extrinsics_fn.read() {
            let result = f(parent_hash, block_number, extrinsics);
            if self.config.verbose {
                match &result {
                    Ok(r) => tracing::debug!(
                        parent = %hex::encode(parent_hash.as_bytes()),
                        block_number,
                        applied = r.applied_extrinsics.len(),
                        failed = r.failed_count,
                        state_root = %hex::encode(r.state_root.as_bytes()),
                        "State execution complete (Task 11.4)"
                    ),
                    Err(e) => tracing::warn!(
                        parent = %hex::encode(parent_hash.as_bytes()),
                        block_number,
                        error = %e,
                        "State execution failed (Task 11.4)"
                    ),
                }
            }
            result
        } else {
            // Fallback: mock execution with zero state root
            // This allows mining to work in scaffold mode without full runtime
            let extrinsics_root = crate::substrate::mining_worker::compute_extrinsics_root(extrinsics);
            Ok(StateExecutionResult {
                applied_extrinsics: extrinsics.to_vec(),
                state_root: H256::zero(),
                extrinsics_root,
                failed_count: 0,
            })
        }
    }

    /// Check if all callbacks are configured
    pub fn is_fully_configured(&self) -> bool {
        self.best_block_fn.read().is_some()
            && self.difficulty_fn.read().is_some()
            && self.pending_txs_fn.read().is_some()
            && self.import_fn.read().is_some()
            // on_import_success_fn is optional
            // execute_extrinsics_fn is optional (fallback to mock)
    }

    /// Check if state execution is configured (Task 11.4)
    pub fn has_state_execution(&self) -> bool {
        self.execute_extrinsics_fn.read().is_some()
    }

    /// Update fallback state (for use when callbacks aren't set)
    pub fn update_fallback(&self, hash: H256, number: u64, difficulty: u32) {
        self.fallback_state.update_best(hash, number);
        self.fallback_state.update_difficulty(difficulty);
    }
}

impl ChainStateProvider for ProductionChainStateProvider {
    fn best_hash(&self) -> H256 {
        if let Some(ref f) = *self.best_block_fn.read() {
            let (hash, _) = f();
            hash
        } else {
            self.fallback_state.best_hash()
        }
    }

    fn best_number(&self) -> u64 {
        if let Some(ref f) = *self.best_block_fn.read() {
            let (_, number) = f();
            number
        } else {
            self.fallback_state.best_number()
        }
    }

    fn difficulty_bits(&self) -> u32 {
        if let Some(ref f) = *self.difficulty_fn.read() {
            f()
        } else {
            self.fallback_state.difficulty_bits()
        }
    }

    fn pending_transactions(&self) -> Vec<Vec<u8>> {
        if let Some(ref f) = *self.pending_txs_fn.read() {
            let mut txs = f();
            txs.truncate(self.config.max_block_transactions);
            txs
        } else {
            self.fallback_state.pending_transactions()
        }
    }

    fn import_block(&self, template: &BlockTemplate, seal: &Blake3Seal) -> Result<H256, String> {
        if let Some(ref f) = *self.import_fn.read() {
            let result = f(template, seal);
            if self.config.verbose {
                match &result {
                    Ok(hash) => tracing::debug!(
                        block_hash = %hex::encode(hash.as_bytes()),
                        block_number = template.number,
                        tx_count = template.extrinsics.len(),
                        "Production provider: block imported via callback"
                    ),
                    Err(e) => tracing::warn!(
                        error = %e,
                        block_number = template.number,
                        "Production provider: block import failed"
                    ),
                }
            }
            
            // Task 11.3: Call on_import_success_fn to clear included transactions
            if result.is_ok() {
                if let Some(ref on_success) = *self.on_import_success_fn.read() {
                    on_success(&template.extrinsics);
                    if self.config.verbose {
                        tracing::debug!(
                            tx_count = template.extrinsics.len(),
                            "Production provider: cleared included transactions (Task 11.3)"
                        );
                    }
                }
            }
            
            result
        } else {
            self.fallback_state.import_block(template, seal)
        }
    }

    fn on_new_block(&self, block_hash: &H256, block_number: u64) {
        // Update fallback state
        self.fallback_state.on_new_block(block_hash, block_number);
        
        if self.config.verbose {
            tracing::debug!(
                block_hash = %hex::encode(block_hash.as_bytes()),
                block_number = block_number,
                "Production provider: notified of new block"
            );
        }
    }

    fn build_block_template(&self) -> BlockTemplate {
        let parent_hash = self.best_hash();
        let block_number = self.best_number() + 1;
        let difficulty_bits = self.difficulty_bits();
        let pending = self.pending_transactions();
        
        let template = BlockTemplate::new(parent_hash, block_number, difficulty_bits);
        
        if pending.is_empty() {
            if self.config.verbose {
                tracing::debug!(
                    block_number,
                    parent = %hex::encode(parent_hash.as_bytes()),
                    "Building empty block template (no pending transactions)"
                );
            }
            return template;
        }
        
        // Task 11.4: Execute extrinsics against runtime state
        match self.execute_extrinsics(&parent_hash, block_number, &pending) {
            Ok(result) => {
                if self.config.verbose {
                    tracing::debug!(
                        block_number,
                        applied = result.applied_extrinsics.len(),
                        failed = result.failed_count,
                        state_root = %hex::encode(result.state_root.as_bytes()),
                        "Block template built with state execution (Task 11.4)"
                    );
                }
                template.with_executed_state(
                    result.applied_extrinsics,
                    result.state_root,
                    result.extrinsics_root,
                )
            }
            Err(e) => {
                tracing::warn!(
                    block_number,
                    error = %e,
                    "State execution failed, falling back to mock (Task 11.4)"
                );
                // Fallback to simple extrinsics without state execution
                template.with_extrinsics(pending)
            }
        }
    }
}

/// Create a production chain state provider
pub fn create_production_chain_state_provider(
    config: ProductionConfig,
) -> Arc<ProductionChainStateProvider> {
    Arc::new(ProductionChainStateProvider::new(config))
}

/// Create a production provider from environment configuration
pub fn create_production_provider_from_env() -> Arc<ProductionChainStateProvider> {
    Arc::new(ProductionChainStateProvider::new(ProductionConfig::from_env()))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_full_client_config_default() {
        let config = FullClientConfig::default();
        assert!(config.in_memory);
        assert!(config.db_path.is_none());
        assert_eq!(config.chain_spec, "dev");
    }

    #[test]
    fn test_full_client_config_development() {
        let config = FullClientConfig::development();
        assert!(config.in_memory);
    }

    #[test]
    fn test_full_client_config_testnet() {
        let path = std::path::PathBuf::from("/tmp/testnet");
        let config = FullClientConfig::testnet(path.clone());
        assert!(!config.in_memory);
        assert_eq!(config.db_path.unwrap(), path);
        assert_eq!(config.chain_spec, "testnet");
    }

    #[test]
    fn test_full_client_config_production() {
        let path = std::path::PathBuf::from("/var/lib/hegemon");
        let config = FullClientConfig::production(path.clone());
        assert!(!config.in_memory);
        assert_eq!(config.db_path.unwrap(), path);
        assert_eq!(config.chain_spec, "mainnet");
    }

    #[test]
    fn test_default_difficulty_bits() {
        // 0x1d0fffff = ~1 minute block time at 1 MH/s
        assert_eq!(DEFAULT_DIFFICULTY_BITS, 0x1d0fffff);
    }

    #[test]
    fn test_chain_state_provider_new() {
        let provider = SubstrateChainStateProvider::new();
        assert_eq!(provider.best_hash(), H256::zero());
        assert_eq!(provider.best_number(), 0);
        assert_eq!(provider.difficulty_bits(), DEFAULT_DIFFICULTY_BITS);
        assert!(provider.pending_transactions().is_empty());
    }

    #[test]
    fn test_chain_state_provider_with_state() {
        let hash = H256::repeat_byte(0x42);
        let provider = SubstrateChainStateProvider::with_state(hash, 100, 0x2000ffff);
        assert_eq!(provider.best_hash(), hash);
        assert_eq!(provider.best_number(), 100);
        assert_eq!(provider.difficulty_bits(), 0x2000ffff);
    }

    #[test]
    fn test_chain_state_provider_update() {
        let provider = SubstrateChainStateProvider::new();
        
        let hash = H256::repeat_byte(0xab);
        let pending = vec![vec![1, 2, 3], vec![4, 5, 6]];
        provider.update_state(hash, 50, 0x1f00ffff, pending.clone());
        
        assert_eq!(provider.best_hash(), hash);
        assert_eq!(provider.best_number(), 50);
        assert_eq!(provider.difficulty_bits(), 0x1f00ffff);
        assert_eq!(provider.pending_transactions(), pending);
    }

    #[test]
    fn test_chain_state_provider_on_new_block() {
        let provider = SubstrateChainStateProvider::with_state(H256::zero(), 10, DEFAULT_DIFFICULTY_BITS);
        
        // Newer block should update
        let hash = H256::repeat_byte(0x11);
        provider.on_new_block(&hash, 15);
        assert_eq!(provider.best_hash(), hash);
        assert_eq!(provider.best_number(), 15);
        
        // Older block should not update
        let old_hash = H256::repeat_byte(0x22);
        provider.on_new_block(&old_hash, 5);
        assert_eq!(provider.best_hash(), hash); // Still the newer one
        assert_eq!(provider.best_number(), 15);
    }

    #[test]
    fn test_chain_state_provider_import_block() {
        let provider = SubstrateChainStateProvider::new();
        provider.add_pending_tx(vec![1, 2, 3]);
        
        let template = BlockTemplate::new(H256::zero(), 1, DEFAULT_DIFFICULTY_BITS);
        let seal = Blake3Seal {
            nonce: 12345,
            difficulty: DEFAULT_DIFFICULTY_BITS,
            work: H256::repeat_byte(0xaa),
        };
        
        let result = provider.import_block(&template, &seal);
        assert!(result.is_ok());
        
        // State should be updated
        assert_eq!(provider.best_number(), 1);
        assert!(provider.pending_transactions().is_empty()); // Cleared
    }

    // Task 10.5: Production provider tests

    #[test]
    fn test_production_config_default() {
        let config = ProductionConfig::default();
        assert_eq!(config.poll_interval_ms, 100);
        assert_eq!(config.max_block_transactions, 1000);
        assert!(!config.verbose);
    }

    #[test]
    fn test_production_config_from_env() {
        // Just verify it doesn't panic
        let _config = ProductionConfig::from_env();
    }

    #[test]
    fn test_production_provider_new() {
        let provider = ProductionChainStateProvider::with_defaults();
        assert!(!provider.is_fully_configured());
        assert_eq!(provider.best_hash(), H256::zero());
        assert_eq!(provider.best_number(), 0);
        assert_eq!(provider.difficulty_bits(), DEFAULT_DIFFICULTY_BITS);
    }

    #[test]
    fn test_production_provider_with_callbacks() {
        let provider = ProductionChainStateProvider::with_defaults();
        
        let expected_hash = H256::repeat_byte(0x42);
        let expected_number = 100u64;
        let hash_for_callback = expected_hash;
        
        provider.set_best_block_fn(move || (hash_for_callback, expected_number));
        provider.set_difficulty_fn(|| 0x2000ffff);
        provider.set_pending_txs_fn(|| vec![vec![1, 2, 3]]);
        provider.set_import_fn(|_, seal| Ok(H256::from_slice(seal.work.as_bytes())));
        
        assert!(provider.is_fully_configured());
        assert_eq!(provider.best_hash(), expected_hash);
        assert_eq!(provider.best_number(), expected_number);
        assert_eq!(provider.difficulty_bits(), 0x2000ffff);
        assert_eq!(provider.pending_transactions(), vec![vec![1, 2, 3]]);
    }

    #[test]
    fn test_production_provider_fallback() {
        let provider = ProductionChainStateProvider::with_defaults();
        
        // Update fallback state
        let hash = H256::repeat_byte(0xab);
        provider.update_fallback(hash, 50, 0x1f00ffff);
        
        // Without callbacks, should use fallback
        assert_eq!(provider.best_hash(), hash);
        assert_eq!(provider.best_number(), 50);
        assert_eq!(provider.difficulty_bits(), 0x1f00ffff);
    }

    #[test]
    fn test_production_provider_import() {
        let provider = ProductionChainStateProvider::with_defaults();
        
        let import_result = H256::repeat_byte(0xcc);
        let import_hash = import_result;
        provider.set_import_fn(move |_, _| Ok(import_hash));
        
        let template = BlockTemplate::new(H256::zero(), 1, DEFAULT_DIFFICULTY_BITS);
        let seal = Blake3Seal {
            nonce: 12345,
            difficulty: DEFAULT_DIFFICULTY_BITS,
            work: H256::repeat_byte(0xaa),
        };
        
        let result = provider.import_block(&template, &seal);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), import_result);
    }

    #[test]
    fn test_production_provider_tx_limit() {
        let config = ProductionConfig {
            max_block_transactions: 2,
            ..Default::default()
        };
        let provider = ProductionChainStateProvider::new(config);
        
        // Return 5 transactions, but config limits to 2
        provider.set_pending_txs_fn(|| {
            vec![vec![1], vec![2], vec![3], vec![4], vec![5]]
        });
        
        let txs = provider.pending_transactions();
        assert_eq!(txs.len(), 2); // Limited by config
    }

    #[test]
    fn test_production_provider_on_new_block() {
        let provider = ProductionChainStateProvider::with_defaults();
        
        let hash = H256::repeat_byte(0x11);
        provider.on_new_block(&hash, 10);
        
        // Should update fallback state
        assert_eq!(provider.fallback_state.best_hash(), hash);
        assert_eq!(provider.fallback_state.best_number(), 10);
    }
    
    #[test]
    fn test_production_provider_on_import_success() {
        use crate::substrate::mining_worker::BlockTemplate;
        use consensus::Blake3Seal;
        
        let provider = ProductionChainStateProvider::new(ProductionConfig::default());
        
        // Track callback invocations
        let callback_called = Arc::new(std::sync::atomic::AtomicBool::new(false));
        let callback_called_clone = callback_called.clone();
        let cleared_txs = Arc::new(std::sync::Mutex::new(Vec::<Vec<u8>>::new()));
        let cleared_txs_clone = cleared_txs.clone();
        
        provider.set_on_import_success_fn(move |included_txs: &[Vec<u8>]| {
            callback_called_clone.store(true, std::sync::atomic::Ordering::SeqCst);
            cleared_txs_clone.lock().unwrap().extend(included_txs.iter().cloned());
        });
        
        // Set up import callback (fallback path)
        provider.set_import_fn(|_template, _seal| {
            // Simulate successful import
            Ok(H256::random())
        });
        
        // Create a simple template with some transactions
        let parent = H256::from([1u8; 32]);
        provider.on_new_block(&parent, 5);
        
        let tx1 = vec![1, 2, 3];
        let tx2 = vec![4, 5, 6];
        let template = BlockTemplate::new(parent, 6, 0x1f_00_ff_ff)
            .with_extrinsics(vec![tx1.clone(), tx2.clone()]);
        
        let seal = Blake3Seal {
            nonce: 1,
            difficulty: 0x1f_00_ff_ff,
            work: H256::zero(),
        };
        
        // Import the block 
        let result = provider.import_block(&template, &seal);
        
        // Should succeed and callback should have been called
        assert!(result.is_ok());
        assert!(callback_called.load(std::sync::atomic::Ordering::SeqCst), 
            "on_import_success callback should be called after successful import");
        
        // Verify the included transactions were passed to the callback
        let cleared = cleared_txs.lock().unwrap();
        assert_eq!(cleared.len(), 2);
        assert!(cleared.contains(&tx1));
        assert!(cleared.contains(&tx2));
    }

    #[test]
    fn test_production_provider_execute_extrinsics() {
        let provider = ProductionChainStateProvider::new(ProductionConfig::default());
        
        let parent = H256::from([1u8; 32]);
        let extrinsics = vec![vec![1, 2, 3], vec![4, 5, 6]];
        
        // Without callback, should return mock execution
        let result = provider.execute_extrinsics(&parent, 1, &extrinsics);
        assert!(result.is_ok());
        let exec_result = result.unwrap();
        assert_eq!(exec_result.applied_extrinsics.len(), 2);
        assert_eq!(exec_result.failed_count, 0);
        // State root should be zero in fallback mode
        assert_eq!(exec_result.state_root, H256::zero());
    }

    #[test]
    fn test_production_provider_execute_extrinsics_with_callback() {
        let provider = ProductionChainStateProvider::new(ProductionConfig::default());
        
        // Set up custom state execution callback
        let custom_state_root = H256::repeat_byte(0xab);
        let custom_extrinsics_root = H256::repeat_byte(0xcd);
        
        provider.set_execute_extrinsics_fn(move |_parent, _number, extrinsics| {
            Ok(StateExecutionResult {
                applied_extrinsics: extrinsics.to_vec(),
                state_root: custom_state_root,
                extrinsics_root: custom_extrinsics_root,
                failed_count: 0,
            })
        });
        
        let parent = H256::from([1u8; 32]);
        let extrinsics = vec![vec![1, 2, 3]];
        
        let result = provider.execute_extrinsics(&parent, 1, &extrinsics);
        assert!(result.is_ok());
        let exec_result = result.unwrap();
        assert_eq!(exec_result.state_root, custom_state_root);
        assert_eq!(exec_result.extrinsics_root, custom_extrinsics_root);
    }

    #[test]
    fn test_production_provider_build_block_template_with_state() {
        use crate::substrate::mining_worker::BlockTemplate;
        
        let provider = ProductionChainStateProvider::new(ProductionConfig::default());
        
        // Set up callbacks
        let parent = H256::repeat_byte(0x11);
        provider.set_best_block_fn(move || (parent, 5));
        provider.set_difficulty_fn(|| 0x1f_00_ff_ff);
        provider.set_pending_txs_fn(|| vec![vec![1, 2, 3], vec![4, 5, 6]]);
        
        let custom_state_root = H256::repeat_byte(0xab);
        provider.set_execute_extrinsics_fn(move |_parent, _number, extrinsics| {
            Ok(StateExecutionResult {
                applied_extrinsics: extrinsics.to_vec(),
                state_root: custom_state_root,
                extrinsics_root: crate::substrate::compute_extrinsics_root(extrinsics),
                failed_count: 0,
            })
        });
        
        // Build template
        let template = provider.build_block_template();
        
        assert_eq!(template.number, 6);
        assert_eq!(template.parent_hash, parent);
        assert_eq!(template.difficulty_bits, 0x1f_00_ff_ff);
        assert_eq!(template.extrinsics.len(), 2);
        assert_eq!(template.state_root, custom_state_root);
    }

    #[test]
    fn test_has_state_execution() {
        let provider = ProductionChainStateProvider::new(ProductionConfig::default());
        
        // Initially no state execution
        assert!(!provider.has_state_execution());
        
        // After setting callback
        provider.set_execute_extrinsics_fn(|_, _, _| {
            Ok(StateExecutionResult {
                applied_extrinsics: vec![],
                state_root: H256::zero(),
                extrinsics_root: H256::zero(),
                failed_count: 0,
            })
        });
        
        assert!(provider.has_state_execution());
    }
}
