<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Hegemon Block Production Dashboard</title>
    <link rel="stylesheet" href="dashboard.css" />
  </head>
  <body>
    <header>
      <div>
        <h1>Block Production Dashboard</h1>
        <p>Read-only metrics streamed from the local node via JSON-RPC.</p>
      </div>
      <div class="status" id="status">
        <span class="warn">Idle</span>
        <span id="last-updated">Last updated: --</span>
      </div>
    </header>
    <main class="wrap">
      <section class="controls">
        <input id="rpc-url" type="text" placeholder="RPC URL" />
        <label class="field">
          Blocks / N min
          <input id="bucket-minutes" type="number" min="1" step="1" />
        </label>
        <button id="refresh">Refresh</button>
        <button id="auto" class="secondary">Auto: On</button>
        <button id="block-details" class="secondary">Block Details</button>
        <button id="recent-hashes" class="secondary">Recent Block Hashes</button>
        <button id="peer-list" class="secondary">Peers</button>
      </section>
      <section class="grid">
        <div class="card">
          <h3>Height</h3>
          <div class="metric" id="height">--</div>
          <div class="subline" id="best-hash">Best hash: --</div>
        </div>
        <div class="card">
          <h3>Hash Rate</h3>
          <div class="metric" id="hash-rate">--</div>
          <div class="subline" id="mining-threads">Threads: --</div>
        </div>
        <div class="card">
          <h3>Difficulty</h3>
          <div class="metric" id="difficulty">--</div>
          <div class="subline" id="block-interval">Avg block interval: --</div>
        </div>
        <div class="card">
          <h3>Blocks Mined</h3>
          <div class="metric" id="blocks-mined">--</div>
          <div class="subline" id="blocks-imported">Imported: --</div>
        </div>
        <div class="card">
          <h3>Peers & Sync</h3>
          <div class="metric" id="peers">--</div>
          <div class="subline" id="syncing">Syncing: --</div>
        </div>
        <div class="card">
          <h3>Supply Digest</h3>
          <div class="metric" id="supply-digest">--</div>
          <div class="subline" id="state-root">State root: --</div>
        </div>
        <div class="card">
          <h3>Observed Address</h3>
          <div class="metric" id="observed-address">--</div>
          <div class="subline" id="observed-address-source">Reported by peers: --</div>
        </div>
      </section>
      <section class="chart">
        <div class="chart-header">
          <h3>Block Frequency</h3>
          <span id="chart-range">Last -- hours</span>
        </div>
        <div class="bar-grid" id="frequency-bars"></div>
      </section>
      <section class="chart">
        <div class="chart-header">
          <h3>Blocks Mined By This Node</h3>
          <span id="mined-range">Last -- hours</span>
        </div>
        <div class="bar-grid" id="mined-bars"></div>
      </section>
      <div class="note">
        Tip: if the browser blocks requests, start the node with
        <code>--rpc-cors=all</code> or open this file through a local HTTP server.
      </div>
    </main>
    <div class="modal hidden" id="block-modal">
      <div class="modal-card">
        <div class="modal-header">
          <h3>Block Details</h3>
          <button id="block-close" class="secondary">Close</button>
        </div>
        <div class="modal-controls">
          <label>
            Block height
            <input id="block-height" type="number" min="0" step="1" />
          </label>
          <button id="block-fetch">Load</button>
          <span class="modal-status" id="block-status">Idle</span>
        </div>
        <div class="modal-section">
          <h4>Block hash</h4>
          <pre id="block-hash">--</pre>
        </div>
        <div class="modal-section">
          <h4>Header (chain_getHeader)</h4>
          <pre id="block-header">--</pre>
        </div>
        <div class="modal-section">
          <h4>Block (chain_getBlock)</h4>
          <pre id="block-body">--</pre>
        </div>
      </div>
    </div>
    <div class="modal hidden" id="recent-modal">
      <div class="modal-card">
        <div class="modal-header">
          <h3>Recent Block Hashes</h3>
          <button id="recent-close" class="secondary">Close</button>
        </div>
        <div class="modal-controls">
          <label>
            Previous blocks
            <input id="recent-count" type="number" min="1" step="1" />
          </label>
          <button id="recent-fetch">Load</button>
          <span class="modal-status" id="recent-status">Idle</span>
        </div>
        <div class="modal-section">
          <h4>Hashes</h4>
          <pre id="recent-list">--</pre>
        </div>
      </div>
    </div>
    <div class="modal hidden" id="peer-modal">
      <div class="modal-card">
        <div class="modal-header">
          <h3>Connected Peers</h3>
          <button id="peer-close" class="secondary">Close</button>
        </div>
        <div class="modal-controls">
          <label>
            Depth
            <input id="peer-depth" type="number" min="1" step="1" />
          </label>
          <button id="peer-fetch">Refresh</button>
          <span class="modal-status" id="peer-status">Idle</span>
        </div>
        <div class="modal-section">
          <h4>Network</h4>
          <div class="peer-network">
            <svg id="peer-network" viewBox="0 0 640 320" role="img" aria-label="Peer network graph"></svg>
          </div>
        </div>
        <div class="modal-section">
          <h4>Peers</h4>
          <pre id="peer-list-output">--</pre>
        </div>
      </div>
    </div>
    <script>
      const DEFAULT_RPC = "http://127.0.0.1:9944";
      const POLL_MS = 5000;
      const DEFAULT_BUCKET_MINUTES = 60;
      const MAX_BUCKETS = 12;
      const TIMESTAMP_BATCH = 500;
      const DEFAULT_PEER_DEPTH = 2;

      const ui = {
        rpcUrl: document.getElementById("rpc-url"),
        refresh: document.getElementById("refresh"),
        auto: document.getElementById("auto"),
        status: document.getElementById("status"),
        lastUpdated: document.getElementById("last-updated"),
        bucketMinutes: document.getElementById("bucket-minutes"),
        blockDetails: document.getElementById("block-details"),
        blockModal: document.getElementById("block-modal"),
        blockClose: document.getElementById("block-close"),
        blockHeight: document.getElementById("block-height"),
        blockFetch: document.getElementById("block-fetch"),
        blockStatus: document.getElementById("block-status"),
        blockHash: document.getElementById("block-hash"),
        blockHeader: document.getElementById("block-header"),
        blockBody: document.getElementById("block-body"),
        recentHashes: document.getElementById("recent-hashes"),
        recentModal: document.getElementById("recent-modal"),
        recentClose: document.getElementById("recent-close"),
        recentCount: document.getElementById("recent-count"),
        recentFetch: document.getElementById("recent-fetch"),
        recentStatus: document.getElementById("recent-status"),
        recentList: document.getElementById("recent-list"),
        peerList: document.getElementById("peer-list"),
        peerModal: document.getElementById("peer-modal"),
        peerClose: document.getElementById("peer-close"),
        peerFetch: document.getElementById("peer-fetch"),
        peerDepth: document.getElementById("peer-depth"),
        peerStatus: document.getElementById("peer-status"),
        peerListOutput: document.getElementById("peer-list-output"),
        peerNetwork: document.getElementById("peer-network"),
        height: document.getElementById("height"),
        bestHash: document.getElementById("best-hash"),
        hashRate: document.getElementById("hash-rate"),
        miningThreads: document.getElementById("mining-threads"),
        difficulty: document.getElementById("difficulty"),
        blockInterval: document.getElementById("block-interval"),
        blocksMined: document.getElementById("blocks-mined"),
        blocksImported: document.getElementById("blocks-imported"),
        peers: document.getElementById("peers"),
        syncing: document.getElementById("syncing"),
        supplyDigest: document.getElementById("supply-digest"),
        stateRoot: document.getElementById("state-root"),
        observedAddress: document.getElementById("observed-address"),
        observedAddressSource: document.getElementById("observed-address-source"),
        chartRange: document.getElementById("chart-range"),
        frequencyBars: document.getElementById("frequency-bars"),
        minedRange: document.getElementById("mined-range"),
        minedBars: document.getElementById("mined-bars"),
      };

      let autoRefresh = true;
      let lastHeight = null;
      let lastHeightTime = null;
      let intervalHandle = null;
      const timestampCache = [];
      let minedTimestampCache = [];
      let timestampSyncInProgress = false;
      let timestampTargetHeight = 0;
      let isSyncingScroll = false;
      let rpcMethodCache = null;
      const peerPositionOverrides = new Map();

      function setStatus(text, kind) {
        ui.status.querySelector("span").textContent = text;
        ui.status.querySelector("span").className = kind;
      }

      function formatNumber(value) {
        if (value === null || value === undefined) return "--";
        return Number(value).toLocaleString("en-US");
      }

      function formatHash(hash) {
        if (!hash || hash === "--") return "--";
        return hash.length > 16 ? `${hash.slice(0, 10)}…${hash.slice(-6)}` : hash;
      }

      function formatRate(value) {
        if (value === null || value === undefined) return "--";
        const units = ["H/s", "kH/s", "MH/s", "GH/s", "TH/s"];
        let idx = 0;
        let v = Number(value);
        while (v >= 1000 && idx < units.length - 1) {
          v /= 1000;
          idx += 1;
        }
        return `${v.toFixed(v >= 100 ? 0 : v >= 10 ? 1 : 2)} ${units[idx]}`;
      }

      function formatDuration(seconds) {
        if (seconds === null || seconds === undefined) return "--";
        return `${seconds.toFixed(1)}s`;
      }

      function formatRpcError(error) {
        if (!error) return "Unknown error";
        if (typeof error === "string") return error;
        if (error.message) return error.message;
        return JSON.stringify(error);
      }

      function collectObservedAddresses(graph) {
        const localPeerId = graph?.local_peer_id ?? graph?.localPeerId;
        const reports = Array.isArray(graph?.reports) ? graph.reports : [];
        if (!localPeerId || reports.length === 0) {
          return [];
        }
        const observed = [];
        reports.forEach((report) => {
          const entries = Array.isArray(report?.peers) ? report.peers : [];
          entries.forEach((entry) => {
            const peerId = entry.peer_id ?? entry.peerId;
            const address = entry.address;
            if (peerId === localPeerId && typeof address === "string" && address.trim() !== "") {
              observed.push(address.trim());
            }
          });
        });
        return observed;
      }

      function summarizeObservedAddress(observed) {
        if (!Array.isArray(observed) || observed.length === 0) {
          return null;
        }
        const counts = new Map();
        observed.forEach((address) => {
          counts.set(address, (counts.get(address) ?? 0) + 1);
        });
        let winner = null;
        let winnerCount = 0;
        counts.forEach((count, address) => {
          if (count > winnerCount) {
            winner = address;
            winnerCount = count;
          }
        });
        if (!winner) {
          return null;
        }
        return {
          address: winner,
          agreement: winnerCount,
          total: observed.length,
        };
      }

      function collectLocalAddresses(graph) {
        const localPeerId = graph?.local_peer_id ?? graph?.localPeerId;
        const localAddresses = new Set();
        if (!localPeerId) {
          return localAddresses;
        }
        const reports = Array.isArray(graph?.reports) ? graph.reports : [];
        reports.forEach((report) => {
          const reporterPeerId = report?.reporter_peer_id ?? report?.reporterPeerId;
          const reporterAddress = report?.reporter_address ?? report?.reporterAddress;
          if (reporterPeerId === localPeerId && typeof reporterAddress === "string" && reporterAddress.trim() !== "") {
            localAddresses.add(reporterAddress.trim());
          }
          const entries = Array.isArray(report?.peers) ? report.peers : [];
          entries.forEach((entry) => {
            const entryPeerId = entry?.peer_id ?? entry?.peerId;
            const entryAddress = entry?.address;
            if (entryPeerId === localPeerId && typeof entryAddress === "string" && entryAddress.trim() !== "") {
              localAddresses.add(entryAddress.trim());
            }
          });
        });
        return localAddresses;
      }

      async function refreshObservedAddress(consensusPeers) {
        try {
          const graph = await callRpc("hegemon_peerGraph");
          const observed = collectObservedAddresses(graph);
          const summary = summarizeObservedAddress(observed);
          if (!summary) {
            ui.observedAddress.textContent = "--";
            ui.observedAddressSource.textContent =
              consensusPeers > 0
                ? "Reported by peers: not reported yet"
                : "Reported by peers: no connected peers";
            return;
          }
          ui.observedAddress.textContent = summary.address;
          ui.observedAddressSource.textContent = `Reported by peers: ${summary.agreement}/${summary.total} reports`;
        } catch (error) {
          console.warn("Failed to load observed address", error);
          ui.observedAddress.textContent = "--";
          ui.observedAddressSource.textContent = `Reported by peers: unavailable (${formatRpcError(
            error
          )})`;
        }
      }

      function isUnsafeRpcError(error) {
        const message = formatRpcError(error).toLowerCase();
        return message.includes("unsafe") && message.includes("extern");
      }

      async function getRpcMethods() {
        if (rpcMethodCache) return rpcMethodCache;
        try {
          const result = await callRpc("rpc_methods");
          const methods = Array.isArray(result) ? result : result?.methods;
          if (!Array.isArray(methods)) {
            return null;
          }
          rpcMethodCache = new Set(methods);
          return rpcMethodCache;
        } catch (error) {
          console.warn("Failed to load rpc_methods", error);
          return null;
        }
      }

      function formatHeight(value) {
        if (value === null || value === undefined) return "--";
        if (typeof value === "string" && value.startsWith("0x")) {
          const parsed = Number.parseInt(value, 16);
          return Number.isFinite(parsed) ? formatNumber(parsed) : value;
        }
        if (Number.isFinite(Number(value))) {
          return formatNumber(Number(value));
        }
        return value;
      }

      function formatJson(value) {
        if (value === null || value === undefined) return "--";
        return JSON.stringify(value, null, 2);
      }

      function clampBucketMinutes(value) {
        if (!Number.isFinite(value)) return DEFAULT_BUCKET_MINUTES;
        return Math.max(1, Math.min(24 * 60, Math.floor(value)));
      }

      function clampPeerDepth(value) {
        if (!Number.isFinite(value)) return DEFAULT_PEER_DEPTH;
        return Math.max(1, Math.min(6, Math.floor(value)));
      }

      function getBucketMinutes() {
        return clampBucketMinutes(Number(ui.bucketMinutes.value));
      }

      function getPeerDepth() {
        return clampPeerDepth(Number(ui.peerDepth.value));
      }

      function buildBuckets(timestamps, minTs, bucketMs, bucketCount) {
        const buckets = new Array(bucketCount).fill(0);
        timestamps.forEach((ts) => {
          const index = Math.floor((ts - minTs) / bucketMs);
          if (index >= 0 && index < bucketCount) {
            buckets[index] += 1;
          }
        });
        return buckets;
      }

      function renderBars(barsEl, buckets, minTs, bucketMs) {
        const maxValue = Math.max(1, ...buckets);
        barsEl.innerHTML = "";
        buckets.forEach((count, index) => {
          const bar = document.createElement("div");
          bar.className = "bar";
          bar.style.height = `${Math.max(8, (count / maxValue) * 140)}px`;
          bar.textContent = count.toString();
          const bucketStart = new Date(minTs + index * bucketMs);
          bar.title = `${bucketStart.toLocaleString()} — ${count} blocks`;
          barsEl.appendChild(bar);
        });
      }

      function renderFrequencyCharts(nowMs) {
        const bucketMinutes = getBucketMinutes();
        const bucketMs = bucketMinutes * 60 * 1000;
        const timestamps = timestampCache
          .map((entry) => entry.timestampMs)
          .filter((value) => typeof value === "number");
        if (!timestamps.length) {
          ui.frequencyBars.innerHTML = "";
          ui.chartRange.textContent = "Syncing timestamps...";
          ui.minedBars.innerHTML = "";
          ui.minedRange.textContent = "Syncing timestamps...";
          return;
        }
        const minTs = Math.min(...timestamps);
        const maxTs = Math.max(...timestamps);
        const bucketCount = Math.max(1, Math.floor((maxTs - minTs) / bucketMs) + 1);
        const buckets = buildBuckets(timestamps, minTs, bucketMs, bucketCount);
        renderBars(ui.frequencyBars, buckets, minTs, bucketMs);

        const minedTimestamps = minedTimestampCache
          .map((entry) => entry.timestampMs)
          .filter((value) => typeof value === "number");
        const minedBuckets = buildBuckets(minedTimestamps, minTs, bucketMs, bucketCount);
        renderBars(ui.minedBars, minedBuckets, minTs, bucketMs);

        if (timestampCache.length && timestampCache.length < timestampTargetHeight + 1) {
          ui.chartRange.textContent = `Syncing ${formatNumber(timestampCache.length)} / ${formatNumber(
            timestampTargetHeight + 1
          )} blocks`;
          ui.minedRange.textContent = "Syncing timestamps...";
        } else {
          ui.chartRange.textContent = `Full chain (${formatNumber(bucketCount)} buckets @ ${bucketMinutes}m)`;
          ui.minedRange.textContent = `Full chain (${formatNumber(bucketCount)} buckets @ ${bucketMinutes}m)`;
        }
      }

      function buildPeerTraversal(graph, maxDepth) {
        const localPeerId = graph?.local_peer_id ?? graph?.localPeerId;
        const localAddresses = collectLocalAddresses(graph);
        const peers = Array.isArray(graph?.peers) ? graph.peers : [];
        const reports = Array.isArray(graph?.reports) ? graph.reports : [];
        const normalizeAddress = (value) => (typeof value === "string" ? value.trim() : "");
        const directPeers = peers
          .map((peer) => ({
            peer_id: peer.peer_id ?? peer.peerId ?? "--",
            address: normalizeAddress(peer.address ?? "--"),
            direction: peer.direction ?? "--",
            best_height: peer.best_height ?? peer.bestHeight,
            best_hash: peer.best_hash ?? peer.bestHash,
            last_seen_secs: peer.last_seen_secs ?? peer.lastSeenSecs,
          }))
          .filter((peer) => {
            if (!peer.address) return false;
            if (localPeerId && peer.peer_id === localPeerId) {
              return false;
            }
            if (localAddresses.has(peer.address)) {
              return false;
            }
            return true;
          });
        const reportByPeerId = new Map();
        const reportByAddress = new Map();
        reports.forEach((report) => {
          const reporterPeerId = report?.reporter_peer_id ?? report?.reporterPeerId ?? "";
          const reporterAddress = normalizeAddress(report?.reporter_address ?? report?.reporterAddress ?? "");
          if (reporterPeerId && !reportByPeerId.has(reporterPeerId)) {
            reportByPeerId.set(reporterPeerId, report);
          }
          if (reporterAddress && reporterAddress !== "--" && !reportByAddress.has(reporterAddress)) {
            reportByAddress.set(reporterAddress, report);
          }
        });

        const nodesByAddress = new Map();
        const edges = [];
        const edgeKeys = new Set();
        const queue = [];
        const enqueue = (entry) => queue.push(entry);
        const upsertNode = (node) => {
          const existing = nodesByAddress.get(node.address);
          if (!existing) {
            nodesByAddress.set(node.address, node);
            return true;
          }
          if (node.distance < existing.distance) {
            existing.distance = node.distance;
          }
          if ((!existing.peer_id || existing.peer_id === "--") && node.peer_id && node.peer_id !== "--") {
            existing.peer_id = node.peer_id;
          }
          if (existing.kind !== "direct" && node.kind === "direct") {
            existing.kind = "direct";
          }
          if (existing.direction === "--" && node.direction && node.direction !== "--") {
            existing.direction = node.direction;
          }
          if ((!existing.best_height || existing.best_height === "--") && node.best_height !== undefined) {
            existing.best_height = node.best_height;
          }
          if ((!existing.best_hash || existing.best_hash === "--") && node.best_hash !== undefined) {
            existing.best_hash = node.best_hash;
          }
          if ((!existing.last_seen_secs || existing.last_seen_secs === "--") && node.last_seen_secs !== undefined) {
            existing.last_seen_secs = node.last_seen_secs;
          }
          return false;
        };
        const addEdge = (from, to, kind) => {
          const key = `${from}->${to}`;
          if (edgeKeys.has(key)) return;
          edgeKeys.add(key);
          edges.push({ from, to, kind });
        };

        directPeers.forEach((peer) => {
          const node = {
            address: peer.address,
            peer_id: peer.peer_id,
            distance: 1,
            kind: "direct",
            direction: peer.direction ?? "--",
            best_height: peer.best_height,
            best_hash: peer.best_hash,
            last_seen_secs: peer.last_seen_secs,
          };
          if (upsertNode(node)) {
            enqueue({ address: peer.address, peer_id: peer.peer_id, distance: 1 });
          }
          addEdge("__local__", peer.address, "direct");
        });

        let traversedReports = 0;
        while (queue.length > 0) {
          const current = queue.shift();
          if (!current) continue;
          if (current.distance >= maxDepth) continue;
          const report =
            (current.peer_id && reportByPeerId.get(current.peer_id)) ||
            reportByAddress.get(current.address);
          if (!report) {
            continue;
          }
          traversedReports += 1;
          const entries = Array.isArray(report?.peers) ? report.peers : [];
          entries.forEach((entry) => {
            const peerId = entry?.peer_id ?? entry?.peerId ?? "--";
            const address = normalizeAddress(entry?.address ?? "--");
            if (!address || address === "--") {
              return;
            }
            if (localPeerId && peerId === localPeerId) {
              return;
            }
            if (localAddresses.has(address)) {
              return;
            }
            const nextDistance = current.distance + 1;
            const node = {
              address,
              peer_id: peerId,
              distance: nextDistance,
              kind: nextDistance === 1 ? "direct" : "indirect",
              direction: "--",
              best_height: undefined,
              best_hash: undefined,
              last_seen_secs: undefined,
            };
            const isNew = upsertNode(node);
            addEdge(current.address, address, "indirect");
            if (isNew) {
              enqueue({ address, peer_id: peerId, distance: nextDistance });
            }
          });
        }

        return {
          nodes: Array.from(nodesByAddress.values()).sort((a, b) => a.distance - b.distance),
          edges,
          traversedReports,
          directCount: directPeers.length,
          knownReports: reports.length,
        };
      }

      function renderPeerNetwork(graph, maxDepth) {
        if (!ui.peerNetwork) return;
        const traversal = buildPeerTraversal(graph, maxDepth);
        const svg = ui.peerNetwork;
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }
        const width = svg.clientWidth || 640;
        const height = svg.clientHeight || 320;
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        const center = { x: width / 2, y: height / 2 };
        const maxRadius = Math.max(90, Math.min(width, height) / 2 - 32);
        const innerRadius = Math.max(70, maxRadius - 70);
        const outerRadius = maxRadius;
        const svgNS = "http://www.w3.org/2000/svg";
        const LOCAL_NODE_KEY = "__local__";
        const createEl = (name, attrs) => {
          const el = document.createElementNS(svgNS, name);
          Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
          return el;
        };
        const nodePositions = new Map();
        const nodeElements = new Map();
        const labelElements = new Map();
        const labelOffsets = new Map();
        const edgeUpdaters = [];
        const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
        const clampPosition = (x, y, radius) => ({
          x: clamp(x, radius + 6, width - radius - 6),
          y: clamp(y, radius + 6, height - radius - 6),
        });
        const refreshEdges = () => {
          edgeUpdaters.forEach((update) => update());
        };
        const setNodePosition = (key, x, y) => {
          const current = nodePositions.get(key);
          if (!current) return;
          const next = clampPosition(x, y, current.radius);
          nodePositions.set(key, { ...current, x: next.x, y: next.y });
          const node = nodeElements.get(key);
          if (node) {
            node.setAttribute("cx", next.x.toString());
            node.setAttribute("cy", next.y.toString());
          }
          const label = labelElements.get(key);
          if (label) {
            const labelOffset = labelOffsets.get(key) ?? -12;
            label.setAttribute("x", next.x.toString());
            label.setAttribute("y", (next.y + labelOffset).toString());
          }
          peerPositionOverrides.set(key, { x: next.x, y: next.y });
          refreshEdges();
        };
        const eventToSvgPoint = (event) => {
          const rect = svg.getBoundingClientRect();
          const scaleX = width / (rect.width || 1);
          const scaleY = height / (rect.height || 1);
          return {
            x: (event.clientX - rect.left) * scaleX,
            y: (event.clientY - rect.top) * scaleY,
          };
        };
        const attachDrag = (node, key) => {
          let pointerId = null;
          let dragging = false;
          node.style.cursor = "grab";
          node.addEventListener("pointerdown", (event) => {
            pointerId = event.pointerId;
            dragging = true;
            node.style.cursor = "grabbing";
            node.setPointerCapture(pointerId);
            event.preventDefault();
          });
          node.addEventListener("pointermove", (event) => {
            if (!dragging || event.pointerId !== pointerId) return;
            const point = eventToSvgPoint(event);
            setNodePosition(key, point.x, point.y);
          });
          const endDrag = (event) => {
            if (event.pointerId !== pointerId) return;
            dragging = false;
            pointerId = null;
            node.style.cursor = "grab";
            if (node.hasPointerCapture(event.pointerId)) {
              node.releasePointerCapture(event.pointerId);
            }
          };
          node.addEventListener("pointerup", endDrag);
          node.addEventListener("pointercancel", endDrag);
        };
        const makeLabel = (text, x, y) => {
          const label = createEl("text", {
            x: x.toString(),
            y: y.toString(),
            "text-anchor": "middle",
            class: "peer-label hidden",
          });
          label.textContent = text;
          svg.appendChild(label);
          return label;
        };
        const registerNode = (key, node, label, initialPos, radius, labelOffset) => {
          const override = peerPositionOverrides.get(key);
          const start = override
            ? clampPosition(override.x, override.y, radius)
            : clampPosition(initialPos.x, initialPos.y, radius);
          nodePositions.set(key, { x: start.x, y: start.y, radius });
          nodeElements.set(key, node);
          labelElements.set(key, label);
          labelOffsets.set(key, labelOffset);
          node.setAttribute("cx", start.x.toString());
          node.setAttribute("cy", start.y.toString());
          label.setAttribute("x", start.x.toString());
          label.setAttribute("y", (start.y + labelOffset).toString());
          attachDrag(node, key);
        };
        const attachHover = (node, label) => {
          const show = () => label.classList.remove("hidden");
          const hide = () => label.classList.add("hidden");
          node.addEventListener("mouseenter", show);
          node.addEventListener("mouseleave", hide);
          node.addEventListener("focus", show);
          node.addEventListener("blur", hide);
        };
        if (traversal.nodes.length === 0) {
          const empty = createEl("text", {
            x: center.x.toString(),
            y: center.y.toString(),
            "text-anchor": "middle",
            "dominant-baseline": "middle",
            class: "peer-empty",
          });
          empty.textContent = "No peer details";
          svg.appendChild(empty);
        }
        const directNodes = traversal.nodes.filter((peer) => peer.distance === 1);
        const directByAddress = new Map(
          directNodes.map((peer) => [peer.address, peer])
        );
        const indirectNodes = traversal.nodes.filter((peer) => peer.distance > 1);
        const directPositions = new Map();
        const directAngleStep = directNodes.length ? (Math.PI * 2) / directNodes.length : 0;
        directNodes.forEach((peer, index) => {
          const angle = directAngleStep * index - Math.PI / 2;
          const x = center.x + Math.cos(angle) * innerRadius;
          const y = center.y + Math.sin(angle) * innerRadius;
          directPositions.set(peer.address, { x, y });
          const line = createEl("line", {
            class: "peer-line",
          });
          svg.appendChild(line);
          edgeUpdaters.push(() => {
            const source = nodePositions.get(LOCAL_NODE_KEY);
            const target = nodePositions.get(peer.address);
            if (!source || !target) return;
            line.setAttribute("x1", source.x.toString());
            line.setAttribute("y1", source.y.toString());
            line.setAttribute("x2", target.x.toString());
            line.setAttribute("y2", target.y.toString());
          });
          const node = createEl("circle", {
            r: "10",
            class: "peer-node direct-node",
          });
          svg.appendChild(node);
          const label = makeLabel(peer.address, x, y - 14);
          const title = createEl("title", {});
          title.textContent = peer.address;
          node.appendChild(title);
          attachHover(node, label);
          registerNode(peer.address, node, label, { x, y }, 10, -14);
        });
        const indirectPositions = new Map();
        const indirectAngleStep = indirectNodes.length ? (Math.PI * 2) / indirectNodes.length : 0;
        indirectNodes.forEach((peer, index) => {
          const angle = indirectAngleStep * index - Math.PI / 2;
          const x = center.x + Math.cos(angle) * outerRadius;
          const y = center.y + Math.sin(angle) * outerRadius;
          indirectPositions.set(peer.address, { x, y });
        });
        traversal.edges
          .filter((edge) => edge.kind === "indirect")
          .forEach((edge) => {
            const line = createEl("line", {
              class: "peer-line peer-line-indirect",
            });
            svg.appendChild(line);
            edgeUpdaters.push(() => {
              const source = nodePositions.get(edge.from) ?? nodePositions.get(LOCAL_NODE_KEY);
              const destination = nodePositions.get(edge.to);
              if (!source || !destination) return;
              line.setAttribute("x1", source.x.toString());
              line.setAttribute("y1", source.y.toString());
              line.setAttribute("x2", destination.x.toString());
              line.setAttribute("y2", destination.y.toString());
            });
          });
        indirectNodes.forEach((peer) => {
          const target = indirectPositions.get(peer.address);
          if (!target) return;
          const node = createEl("circle", {
            r: "9",
            class: "peer-node indirect-node",
          });
          svg.appendChild(node);
          const label = makeLabel(peer.address, target.x, target.y - 12);
          const title = createEl("title", {});
          title.textContent = peer.address;
          node.appendChild(title);
          attachHover(node, label);
          registerNode(peer.address, node, label, target, 9, -12);
        });
        const local = createEl("circle", {
          r: "14",
          class: "peer-node local-node",
        });
        svg.appendChild(local);
        const localLabel = createEl("text", {
          "text-anchor": "middle",
          class: "peer-label",
        });
        localLabel.textContent = "local";
        svg.appendChild(localLabel);
        registerNode(LOCAL_NODE_KEY, local, localLabel, center, 14, 26);
        refreshEdges();
        return traversal;
      }

      async function callRpc(method, params = []) {
        const response = await fetch(ui.rpcUrl.value, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: Date.now(),
            method,
            params,
          }),
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const payload = await response.json();
        if (payload.error) {
          throw new Error(payload.error.message || "RPC error");
        }
        return payload.result;
      }

      async function refreshMinedBlocks() {
        try {
          const mined = await callRpc("hegemon_minedBlockTimestamps");
          minedTimestampCache = mined.map((entry) => ({
            height: entry.height,
            timestampMs: entry.timestamp_ms ?? entry.timestampMs ?? null,
          }));
        } catch (error) {
          console.error(error);
          minedTimestampCache = [];
        }
      }

      async function refresh() {
        setStatus("Loading...", "warn");
        try {
          const [consensus, mining, telemetry] = await Promise.all([
            callRpc("hegemon_consensusStatus"),
            callRpc("hegemon_miningStatus"),
            callRpc("hegemon_telemetry"),
          ]);

          ui.height.textContent = formatNumber(consensus.height);
          ui.bestHash.textContent = `Best hash: ${formatHash(consensus.best_hash)}`;
          ui.hashRate.textContent = formatRate(mining.hash_rate);
          ui.miningThreads.textContent = `Threads: ${formatNumber(mining.threads)} | Mining: ${
            mining.is_mining ? "Yes" : "No"
          }`;
          ui.difficulty.textContent = formatNumber(mining.difficulty);

          const now = Date.now();
          if (lastHeight !== null && consensus.height > lastHeight) {
            const deltaBlocks = consensus.height - lastHeight;
            const deltaSecs = (now - lastHeightTime) / 1000;
            ui.blockInterval.textContent = `Avg block interval: ${formatDuration(
              deltaSecs / deltaBlocks
            )}`;
          } else if (ui.blockInterval.textContent === "--") {
            ui.blockInterval.textContent = "Avg block interval: --";
          }
          lastHeight = consensus.height;
          lastHeightTime = now;
          scheduleTimestampSync(consensus.height);
          await refreshMinedBlocks();
          renderFrequencyCharts(now);

          ui.blocksMined.textContent = formatNumber(mining.blocks_found);
          ui.blocksImported.textContent = `Imported: ${formatNumber(telemetry.blocks_imported)}`;

          ui.peers.textContent = formatNumber(consensus.peers);
          ui.syncing.textContent = `Syncing: ${consensus.syncing ? "Yes" : "No"}`;

          ui.supplyDigest.textContent = consensus.supply_digest?.toString?.() ?? "--";
          ui.stateRoot.textContent = `State root: ${formatHash(consensus.state_root)}`;
          await refreshObservedAddress(consensus.peers);

          ui.lastUpdated.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
          setStatus("Connected", "ok");
        } catch (error) {
          setStatus("Disconnected", "bad");
          ui.lastUpdated.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
          console.error(error);
        }
      }

      function setBlockStatus(text) {
        ui.blockStatus.textContent = text;
      }

      function openBlockModal() {
        const nextHeight = Number.isFinite(lastHeight) ? lastHeight : 0;
        ui.blockHeight.value = nextHeight.toString();
        ui.blockModal.classList.remove("hidden");
        setBlockStatus("Idle");
      }

      function closeBlockModal() {
        ui.blockModal.classList.add("hidden");
      }

      async function loadBlockDetails() {
        const height = Number(ui.blockHeight.value);
        if (!Number.isFinite(height) || height < 0) {
          setBlockStatus("Enter a valid height.");
          return;
        }
        setBlockStatus("Loading block data...");
        ui.blockHash.textContent = "--";
        ui.blockHeader.textContent = "--";
        ui.blockBody.textContent = "--";
        try {
          const blockHash = await callRpc("chain_getBlockHash", [height]);
          if (!blockHash) {
            setBlockStatus("No block at that height.");
            return;
          }
          const [header, block] = await Promise.all([
            callRpc("chain_getHeader", [blockHash]),
            callRpc("chain_getBlock", [blockHash]),
          ]);
          ui.blockHash.textContent = blockHash;
          ui.blockHeader.textContent = formatJson(header);
          ui.blockBody.textContent = formatJson(block);
          setBlockStatus("Loaded.");
        } catch (error) {
          console.error(error);
          setBlockStatus("Failed to load block details.");
        }
      }

      function setRecentStatus(text) {
        ui.recentStatus.textContent = text;
      }

      function setPeerStatus(text) {
        ui.peerStatus.textContent = text;
      }

      function openPeerModal() {
        ui.peerDepth.value = localStorage.getItem("hegemonPeerDepth") || DEFAULT_PEER_DEPTH;
        ui.peerListOutput.textContent = "--";
        setPeerStatus("Loading peers...");
        ui.peerModal.classList.remove("hidden");
        renderPeerNetwork([], getPeerDepth());
        loadPeers();
      }

      function closePeerModal() {
        ui.peerModal.classList.add("hidden");
      }

      async function loadPeers() {
        const depth = getPeerDepth();
        ui.peerDepth.value = depth.toString();
        localStorage.setItem("hegemonPeerDepth", depth.toString());
        setPeerStatus("Loading peers...");
        ui.peerListOutput.textContent = "--";
        try {
          const graph = await callRpc("hegemon_peerGraph");
          const traversal = buildPeerTraversal(graph, depth);
          if (traversal.nodes.length === 0) {
            let peerCount = null;
            try {
              const health = await callRpc("system_health");
              peerCount = health?.peers;
            } catch (error) {
              console.warn("Failed to load system_health", error);
            }
            ui.peerListOutput.textContent =
              peerCount === null || peerCount === undefined
                ? "No peer details reported."
                : `No peer details reported. Connected peers: ${formatNumber(peerCount)}.`;
            setPeerStatus("No peer details reported.");
            renderPeerNetwork([], depth);
            return;
          }
          ui.peerListOutput.textContent = traversal.nodes
            .map((peer, index) => {
              const peerId = peer.peer_id ?? peer.peerId ?? `peer-${index + 1}`;
              const address = peer.address ?? "--";
              const direction = peer.direction ?? "--";
              const bestNumber = formatHeight(peer.best_height ?? peer.bestHeight);
              const bestHash = formatHash(peer.best_hash ?? peer.bestHash);
              const lastSeen = Number(peer.last_seen_secs ?? peer.lastSeenSecs ?? 0);
              return `[hop ${peer.distance}] ${peerId} | ${direction} | ${address} | best: ${bestNumber} @ ${bestHash} | seen ${formatNumber(
                lastSeen
              )}s ago`;
            })
            .join("\n");
          setPeerStatus(
            `Loaded ${traversal.nodes.length} peer(s), depth ${depth}, traversed ${traversal.traversedReports}/${traversal.knownReports} reports.`
          );
          renderPeerNetwork(graph, depth);
        } catch (error) {
          console.error(error);
          setPeerStatus(`Failed to load peers: ${formatRpcError(error)}`);
          ui.peerListOutput.textContent = "Check that the node exposes hegemon_peerGraph.";
          renderPeerNetwork([], depth);
        }
      }

      async function getBestHeight() {
        if (Number.isFinite(lastHeight)) {
          return lastHeight;
        }
        const header = await callRpc("chain_getHeader");
        return Number.parseInt(header.number, 16);
      }

      function openRecentModal() {
        ui.recentCount.value = "7";
        ui.recentList.textContent = "--";
        setRecentStatus("Idle");
        ui.recentModal.classList.remove("hidden");
      }

      function closeRecentModal() {
        ui.recentModal.classList.add("hidden");
      }

      async function loadRecentHashes() {
        const count = Math.floor(Number(ui.recentCount.value));
        if (!Number.isFinite(count) || count < 1) {
          setRecentStatus("Enter a valid count.");
          return;
        }
        setRecentStatus("Loading hashes...");
        ui.recentList.textContent = "--";
        try {
          const best = await getBestHeight();
          const heights = [];
          for (let i = 0; i < count; i += 1) {
            const height = best - i;
            if (height < 0) break;
            heights.push(height);
          }
          const hashes = await Promise.all(
            heights.map((height) => callRpc("chain_getBlockHash", [height]))
          );
          ui.recentList.textContent = heights
            .map((height, index) => `${height}: ${hashes[index] ?? "--"}`)
            .join("\n");
          setRecentStatus(`Loaded ${heights.length} hashes (best: ${best}).`);
        } catch (error) {
          console.error(error);
          setRecentStatus("Failed to load hashes.");
        }
      }

      async function scheduleTimestampSync(bestHeight) {
        timestampTargetHeight = bestHeight;
        if (timestampSyncInProgress) {
          return;
        }
        timestampSyncInProgress = true;
        try {
          let nextHeight = timestampCache.length > 0 ? timestampCache[timestampCache.length - 1].height + 1 : 0;
          if (nextHeight > bestHeight) {
            timestampSyncInProgress = false;
            return;
          }
          while (nextHeight <= bestHeight) {
            const end = Math.min(bestHeight, nextHeight + TIMESTAMP_BATCH - 1);
            const batch = await callRpc("hegemon_blockTimestamps", [nextHeight, end]);
            for (const entry of batch) {
              timestampCache.push({
                height: entry.height,
                timestampMs: entry.timestamp_ms ?? entry.timestampMs ?? null,
              });
            }
            nextHeight = end + 1;
            renderFrequencyCharts(Date.now());
            if (!autoRefresh) {
              break;
            }
          }
        } catch (error) {
          console.error(error);
        } finally {
          timestampSyncInProgress = false;
        }
      }

      function startAuto() {
        if (intervalHandle) return;
        intervalHandle = setInterval(refresh, POLL_MS);
      }

      function stopAuto() {
        if (intervalHandle) {
          clearInterval(intervalHandle);
          intervalHandle = null;
        }
      }

      function toggleAuto() {
        autoRefresh = !autoRefresh;
        ui.auto.textContent = `Auto: ${autoRefresh ? "On" : "Off"}`;
        if (autoRefresh) {
          startAuto();
          refresh();
        } else {
          stopAuto();
        }
      }

      function init() {
        ui.rpcUrl.value = localStorage.getItem("hegemonRpcUrl") || DEFAULT_RPC;
        ui.bucketMinutes.value = localStorage.getItem("hegemonBucketMinutes") || DEFAULT_BUCKET_MINUTES;
        ui.chartRange.textContent = "Syncing timestamps...";
        ui.minedRange.textContent = "Syncing timestamps...";
        const syncScroll = (source, target) => {
          if (isSyncingScroll) return;
          isSyncingScroll = true;
          target.scrollLeft = source.scrollLeft;
          requestAnimationFrame(() => {
            isSyncingScroll = false;
          });
        };
        ui.frequencyBars.addEventListener("scroll", () => syncScroll(ui.frequencyBars, ui.minedBars));
        ui.minedBars.addEventListener("scroll", () => syncScroll(ui.minedBars, ui.frequencyBars));
        ui.rpcUrl.addEventListener("change", () => {
          localStorage.setItem("hegemonRpcUrl", ui.rpcUrl.value.trim());
          refresh();
        });
        ui.bucketMinutes.addEventListener("change", () => {
          const next = clampBucketMinutes(Number(ui.bucketMinutes.value));
          ui.bucketMinutes.value = next.toString();
          localStorage.setItem("hegemonBucketMinutes", ui.bucketMinutes.value);
          renderFrequencyCharts(Date.now());
        });
        ui.refresh.addEventListener("click", refresh);
        ui.auto.addEventListener("click", toggleAuto);
        ui.blockDetails.addEventListener("click", openBlockModal);
        ui.blockClose.addEventListener("click", closeBlockModal);
        ui.blockFetch.addEventListener("click", loadBlockDetails);
        ui.blockHeight.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            loadBlockDetails();
          }
        });
        ui.blockModal.addEventListener("click", (event) => {
          if (event.target === ui.blockModal) {
            closeBlockModal();
          }
        });
        ui.recentHashes.addEventListener("click", openRecentModal);
        ui.recentClose.addEventListener("click", closeRecentModal);
        ui.recentFetch.addEventListener("click", loadRecentHashes);
        ui.recentCount.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            loadRecentHashes();
          }
        });
        ui.recentModal.addEventListener("click", (event) => {
          if (event.target === ui.recentModal) {
            closeRecentModal();
          }
        });
        ui.peerList.addEventListener("click", openPeerModal);
        ui.peerClose.addEventListener("click", closePeerModal);
        ui.peerFetch.addEventListener("click", loadPeers);
        ui.peerDepth.addEventListener("change", () => {
          const next = clampPeerDepth(Number(ui.peerDepth.value));
          ui.peerDepth.value = next.toString();
          localStorage.setItem("hegemonPeerDepth", next.toString());
          if (!ui.peerModal.classList.contains("hidden")) {
            loadPeers();
          }
        });
        ui.peerModal.addEventListener("click", (event) => {
          if (event.target === ui.peerModal) {
            closePeerModal();
          }
        });
        startAuto();
        refresh();
      }

      init();
    </script>
  </body>
</html>
