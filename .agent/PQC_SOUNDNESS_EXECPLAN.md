# PQC soundness: upgrade to 384-bit hash commitments (≈128-bit quantum collision security)

This ExecPlan is a living document. The sections `Progress`, `Surprises & Discoveries`, `Decision Log`, and `Outcomes & Retrospective` must be kept up to date as work proceeds.

This repository contains ExecPlan requirements in `.agent/PLANS.md` (from the repository root). This document must be maintained in accordance with that file. This work also follows `AGENTS.md` at the repository root (setup commands, documentation expectations).

## Purpose / Big Picture

Today, many of Hegemon’s binding commitments (note commitments, nullifiers, Merkle roots, DA roots, and the STARK proof system’s Merkle commitments) are 256-bit digests. Under the best-known quantum collision attack model for random-looking hashes (Brassard–Høyer–Tapp style), collisions cost about `O(2^(n/3))` work for an `n`-bit digest. For `n = 256`, this caps collision security at ~`256/3 ≈ 85` bits. The goal of this ExecPlan is to raise collision security to ~128 bits in the same model by moving all *binding* commitments to 384-bit digests (because `384/3 = 128`).

After this change:

1. The chain’s core “no double spend / consistent state transition” invariants rely on 384-bit commitments (≈128-bit quantum collision security), not 256-bit ones.
2. STARK proofs generated by our Winterfell-based circuits use a 384-bit hash digest for Merkle commitments and Fiat–Shamir transcripts (so the proof system’s binding commitments are also ≈128-bit quantum-collision secure).
3. The node, runtime, wallet, and runbooks all agree on the new widths and remain end-to-end runnable: you can run a dev node, create/submit transactions, mine blocks, and verify commitment proofs with the new parameters.

## Progress

- [x] (2026-01-06 15:05Z) Created working branch `PQC_soundness`.
- [ ] Record a repo-wide “hash width inventory” (what is 256-bit today, what is already 384-bit) and lock it in with tests/docs.
- [ ] Prototype and land a local fork of Winterfell/winter-crypto which supports 48-byte digests, plus a 384-bit hasher usable by our circuits.
- [ ] Wire the Winterfell 384-bit hasher through all STARK circuits and adjust proof-size caps/tests accordingly.
- [ ] Upgrade application-level commitments (note commitments, nullifiers, Merkle roots, DA roots, commitment-proof public inputs) from 32-byte to 48-byte encodings end-to-end (runtime ↔ node ↔ wallet ↔ circuits).
- [ ] Update chain spec / versioning and produce a demonstrably working dev network flow on the new commitment widths.
- [ ] Update `DESIGN.md`, `METHODS.md`, `README.md`, and runbooks to make the 384-bit / PQC rationale the documented source of truth.

## Surprises & Discoveries

- Observation: Winterfell’s `winter-crypto` `Digest` trait currently hard-caps digests at 32 bytes (`fn as_bytes(&self) -> [u8; 32]`).
  Evidence: `$HOME/.cargo/registry/src/.../winter-crypto-0.13.1/src/hash/mod.rs`.
- Observation: We already have a 384-bit commitment in the consensus header: `consensus::StarkCommitment = [u8; 48]` computed via SHA-384 over transaction hashes.
  Evidence: `consensus/src/types.rs` (`compute_proof_commitment`).

## Decision Log

- Decision: Target 384-bit digests for “binding commitments” to reach ≈128-bit quantum collision security under `O(2^(n/3))` collision search.
  Rationale: 256-bit digests cap out at ~85-bit quantum collision security; 384-bit yields 128-bit (`384/3`).
  Date/Author: 2026-01-06 / Codex.
- Decision: Do not “paper over” Winterfell’s 32-byte digest limit; we will fork/vendor Winterfell/winter-crypto to support 48-byte digests for Merkle commitments and Fiat–Shamir transcripts.
  Rationale: If the STARK proof system keeps 256-bit Merkle digests, the proof system’s binding commitments remain ~85-bit quantum-collision secure even if application-level hashes widen.
  Date/Author: 2026-01-06 / Codex.

## Outcomes & Retrospective

Not started yet. This section must summarize what shipped and what did not once milestones complete.

## Context and Orientation

### What “PQC soundness” means in this plan

We use “PQC soundness” here in the narrow, operational sense relevant to this codebase: the ability of an attacker with a quantum computer to break the *binding* property of hash-based commitments by finding hash collisions. In many places we treat hash outputs as *commitments* (a value that “binds” you to some data). If an attacker can find collisions cheaply, they may be able to:

1. Open a Merkle commitment to two different leaves/paths (breaking the binding of Merkle roots).
2. Create two different payloads that share a commitment (breaking the binding of note commitments, nullifiers, DA roots, etc.).

Under the best-known generic quantum collision algorithms for random-looking hashes, the cost to find a collision is roughly `O(2^(n/3))` for an `n`-bit output. So:

1. 256-bit digests: ~`2^(256/3)` work ⇒ ~85-bit security.
2. 384-bit digests: ~`2^(384/3)` work ⇒ 128-bit security.

This plan’s goal is therefore: ensure that every binding commitment we rely on is at least 384 bits, end-to-end.

### What exists today (important concrete files)

The following modules are the “spine” of the current commitment/proof system:

1. `circuits/transaction-core/src/hashing.rs` implements the field-friendly Poseidon-style sponge used for note commitments, nullifiers, Merkle nodes, and canonical byte encodings. It currently uses four 64-bit limbs (32 bytes) for these values.
2. `state/merkle/src/lib.rs` implements the append-only commitment tree and stores commitments/roots as 32-byte hashes.
3. `pallets/shielded-pool/src/types.rs` defines on-chain types for commitments/nullifiers and caps STARK proof bytes (`STARK_PROOF_MAX_SIZE`).
4. `consensus/src/types.rs` defines consensus-level commitment types. Most are 32 bytes; `StarkCommitment` is already 48 bytes.
5. `circuits/block/src/commitment_air.rs` and `circuits/block/src/commitment_prover.rs` define the commitment block proof. Many public inputs are 32-byte values (state roots, nullifier root, DA root, `tx_proofs_commitment`).
6. `node/src/substrate/service.rs` and `consensus/src/proof.rs` wire commitment proofs + parallel transaction verification into block production/import.

The STARK proof system itself comes from the `winterfell` / `winter-crypto` crates (currently pulled from crates.io). The internal Merkle commitments and Fiat–Shamir transcript hashing currently assume 32-byte digests.

## Plan of Work

This change is large and breaking. The plan is structured to keep the project runnable at every milestone by preferring additive changes (introducing parallel 384-bit codepaths and tests) before deleting the 256-bit ones. Once the new path is validated end-to-end, we flip defaults and remove legacy code.

### Milestone 0: Inventory and acceptance criteria

Add an explicit “hash width inventory” to the codebase so we can prove what is 256-bit vs 384-bit and what the target is. The inventory must include, at minimum:

1. The digest sizes used by Winterfell circuits (transaction, batch, settlement, block commitment proof).
2. The byte widths of on-chain commitments: note commitments, nullifiers, Merkle roots, DA roots, commitment-proof public inputs.
3. The byte widths of consensus header commitments (`proof_commitment`, `fee_commitment`, `version_commitment`, etc.).

This milestone ends when a CI test fails if any of these “expected widths” regress back to 32 bytes.

### Milestone 1: Winterfell 48-byte digest fork (prototype → production)

Winterfell’s `Digest` interface currently caps digests at 32 bytes. To get 384-bit digests, we will vendor/fork the relevant Winterfell crates into this repository and update them to support 48-byte digests.

Concrete scope:

1. Add a `vendor/` (or `crates/`) directory containing a forked copy of the `winter-crypto` and `winterfell` crates we use (matching the exact versions currently in `Cargo.lock`).
2. Modify the digest abstraction so that a digest type can be 48 bytes and can be serialized/deserialized in proofs and Merkle trees.
3. Implement a 384-bit hasher suitable for Merkle commitments and Fiat–Shamir. Prefer BLAKE3 in XOF mode because we already use `blake3::Hasher::finalize_xof()` elsewhere in this repo and it is fast.
4. Update proof serialization so the proof format is self-consistent for 48-byte digests (it is OK for this to be a breaking proof format change; our protocol versioning must reflect it).

This milestone must include a “toy circuit” validation:

1. Prove and verify a transaction proof (or a minimal test circuit) using the new 48-byte digest.
2. Assert the produced proof bytes are non-empty and verifiable.

### Milestone 2: Wire Winterfell 384-bit hashing through our circuits

Once the forked Winterfell supports 48-byte digests, update our circuits to use the new hasher as their `HashFn`/Merkle hasher:

1. `circuits/transaction` (transaction STARK proofs).
2. `circuits/batch`, `circuits/settlement`, `circuits/block` (commitment block proof).
3. Any other proof-producing crates (`circuits/disclosure`, `circuits/epoch` if enabled).

Update size caps and tests to match the new proof sizes:

1. Raise `pallets/shielded-pool/src/types.rs:STARK_PROOF_MAX_SIZE` if needed (expect ~1.5× growth if Merkle digests grow 32 → 48 bytes).
2. Update tests that assert “proof < 200_000 bytes” to reflect the new cap or to assert a bound derived from `ProofOptions`.

This milestone ends when `make test` passes with the Winterfell fork and 48-byte digests, even if application-level commitments are still 32 bytes.

### Milestone 3: Upgrade application-level commitments to 48 bytes end-to-end

This is the largest breaking step. We will upgrade the protocol’s “commitment width” (note commitments, nullifiers, Merkle roots, DA roots, and commitment-proof public inputs) from 32 bytes to 48 bytes.

Key principles:

1. Every place that previously accepted or emitted `[u8; 32]` commitments must be upgraded (runtime storage, extrinsics, RPC codecs, wallet serialization).
2. The STARK constraints must bind the new 48-byte values (no “compute 48 bytes off-chain and only prove 32 bytes” shortcuts).
3. Canonical encoding checks must be extended to 48 bytes (six 64-bit limbs) and used everywhere we previously used `is_canonical_bytes32`.

Concrete implementation outline:

1. In `circuits/transaction-core`:
   - Introduce a 48-byte commitment encoding type and conversion helpers (six Goldilocks limbs).
   - Update note commitments, nullifiers, and Merkle node hashes to produce 48-byte outputs.
   - Update public input encoding/decoding accordingly.
2. In `state/merkle`:
   - Upgrade stored node/leaf/root widths to 48 bytes.
   - Update root history storage and authentication path formats accordingly.
3. In `state/da`:
   - Upgrade DA chunk Merkle roots and proofs (`DaRoot`) to 48 bytes and update RPC endpoints and storage if any.
4. In `pallets/shielded-pool` and runtime integration:
   - Change on-chain commitment/nullifier types from `[u8; 32]` to `[u8; 48]` and update SCALE encodings everywhere they appear.
   - Add a runtime storage version bump and a migration strategy. Because this changes the meaning of existing stored commitments, the simplest acceptable approach for alpha is to require a fresh chain (new genesis). If we do a migration, it must be fully specified and tested.
5. In `consensus` and `node`:
   - Update all consensus types (`Nullifier`, `Commitment`, roots, DA root) to 48 bytes and ensure block production/import recomputations match the new widths.
6. In `wallet`:
   - Update all serialization formats that assume 32-byte commitments/nullifiers/anchors.
   - Ensure `wallet` can still craft and submit transactions end-to-end.

This milestone ends when a dev node can produce and import blocks with:

1. 48-byte commitments and nullifiers.
2. 48-byte Merkle roots for the shielded pool state.
3. Commitment block proofs whose public inputs carry 48-byte roots/commitments.

### Milestone 4: Protocol versioning, docs, and runbooks

Because this is a breaking protocol change, we must:

1. Bump circuit version identifiers (see `circuits/transaction-core/src/constants.rs:CIRCUIT_VERSION` and any analogous constants).
2. Update consensus protocol specs under `consensus/spec/` to reflect the new field widths.
3. Update `DESIGN.md` and `METHODS.md` so they explicitly state the new 384-bit / 128-quantum-collision target and how it is achieved (and remove any stale “256-bit is enough” language).
4. Update `README.md` whitepaper section where it references recursive proofs or old hash widths so the canonical whitepaper matches shipped behavior.
5. Update runbooks in `runbooks/` so the “first run” flow still works (build node/wallet, start dev node, mine a block, query commitment proof RPC, submit a transfer).

## Concrete Steps

All commands below are run from the repository root.

1. Setup toolchains:

   - `make setup`

2. Build node and wallet artifacts:

   - `make node`
   - `cargo build -p wallet --release`

3. Run tests (baseline and after each milestone):

   - `cargo fmt --all`
   - `make test`

4. Run an end-to-end dev node once Milestone 3+ is complete:

   - `HEGEMON_MINE=1 ./target/release/hegemon-node --dev --tmp`

   Expected behavior: blocks are produced; querying the block commitment proof RPC returns a proof whose public inputs include 48-byte commitments/roots.

## Validation and Acceptance

The work is accepted when all of the following are true:

1. Hash width inventory test(s) pass and prove that all binding commitments are 48 bytes (384 bits).
2. `make test` passes in CI.
3. A dev node mines blocks and validates them end-to-end on the new commitment widths.
4. The wallet can craft and submit a shielded transfer that is accepted into a mined block under the new commitment widths.
5. Documentation (`DESIGN.md`, `METHODS.md`, `README.md` whitepaper section, and runbooks) clearly describes the 384-bit change and no longer implies 256-bit commitments provide 128-bit quantum collision security.

## Idempotence and Recovery

This work is a protocol-breaking change. The safest development loop is:

1. Prefer running dev chains with `--tmp` or with a fresh `--base-path` per iteration.
2. When changing on-chain types/encodings, assume old chain databases are incompatible and delete local dev state rather than attempting partial reuse.

If the Winterfell fork approach proves too invasive, the fallback is to explicitly scope “PQC soundness” to application-level commitments only, document the residual ~85-bit quantum collision security of the proof system’s internal Merkle commitments, and treat full proof-system PQC hardening as a separate project. This fallback is not the target of this ExecPlan unless recorded in the Decision Log.

## Artifacts and Notes

Useful existing evidence in this repo:

1. `DESIGN.md` already explicitly notes: “With 256-bit digests, PQ collision resistance caps at ~85 bits unless digest sizes are widened.”
2. `consensus/src/types.rs` already uses a 48-byte `StarkCommitment` via SHA-384 for `proof_commitment`.

When implementing, preserve short transcripts (proof sizes, digest sizes, dev node logs) in this section as indented snippets so a novice can compare expected vs actual behavior.

## Interfaces and Dependencies

At the end of this plan, the following interfaces must exist and be used consistently:

1. A 48-byte digest type for Winterfell proof system hashing, used by all STARK circuits in this repository (transaction, block commitment, batch, settlement, disclosure, epoch if enabled).
2. A 48-byte “commitment” encoding used for on-chain commitments/nullifiers/roots, with:

   - Canonical encoding checks.
   - Conversions to/from field elements for circuit public input encoding.
   - Stable serialization used by wallet and node RPC surfaces.

3. Updated runtime pallet types to store 48-byte commitments/nullifiers and enforce updated size bounds for proofs/extrinsics.

