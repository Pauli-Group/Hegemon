//! Real STARK verifier for transaction circuits.
//!
//! This module provides verification of STARK proofs generated by the transaction prover.

use winterfell::{
    crypto::{DefaultRandomCoin, MerkleTree},
    math::fields::f64::BaseElement,
    verify, AcceptableOptions, Proof, VerifierError,
};
use winter_crypto::hashers::Blake3_256;

use crate::{
    stark_air::{TransactionAirStark, TransactionPublicInputsStark},
    TransactionCircuitError,
};

// TYPE ALIASES
// ================================================================================================

type Blake3 = Blake3_256<BaseElement>;

// VERIFICATION
// ================================================================================================

/// Verifies a STARK proof against the given public inputs.
///
/// Returns `Ok(())` if the proof is valid, or an error if verification fails.
pub fn verify_transaction_proof(
    proof: &Proof,
    pub_inputs: &TransactionPublicInputsStark,
) -> Result<(), TransactionCircuitError> {
    // Define acceptable proof options
    let acceptable_options = AcceptableOptions::OptionSet(vec![
        crate::stark_prover::default_proof_options(),
        crate::stark_prover::fast_proof_options(),
    ]);

    // Verify using winterfell's verifier
    verify::<TransactionAirStark, Blake3, DefaultRandomCoin<Blake3>, MerkleTree<Blake3>>(
        proof.clone(),
        pub_inputs.clone(),
        &acceptable_options,
    )
    .map_err(|e| match e {
        VerifierError::ProofDeserializationError(_) => {
            TransactionCircuitError::ConstraintViolation("proof deserialization failed")
        }
        _ => TransactionCircuitError::ConstraintViolation("proof verification failed"),
    })
}

/// Verifies a STARK proof from raw bytes.
pub fn verify_transaction_proof_bytes(
    proof_bytes: &[u8],
    pub_inputs: &TransactionPublicInputsStark,
) -> Result<(), TransactionCircuitError> {
    let proof = Proof::from_bytes(proof_bytes).map_err(|_| {
        TransactionCircuitError::ConstraintViolation("invalid proof bytes")
    })?;

    verify_transaction_proof(&proof, pub_inputs)
}

/// Result of proof verification with detailed information.
#[derive(Clone, Debug)]
pub struct VerificationResult {
    /// Whether the proof is valid
    pub valid: bool,
    /// Size of the proof in bytes
    pub proof_size: usize,
}

/// Verifies a proof and returns detailed result.
pub fn verify_with_details(
    proof: &Proof,
    pub_inputs: &TransactionPublicInputsStark,
) -> VerificationResult {
    let valid = verify_transaction_proof(proof, pub_inputs).is_ok();
    let proof_bytes = proof.to_bytes();
    
    VerificationResult {
        valid,
        proof_size: proof_bytes.len(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::stark_prover::{TransactionProverStark, fast_proof_options};
    use crate::note::{InputNoteWitness, OutputNoteWitness, NoteData};
    use crate::witness::TransactionWitness;
    use winterfell::Prover;

    fn make_balanced_witness() -> TransactionWitness {
        // Create a balanced witness where inputs = outputs + fee
        let input_note = NoteData {
            value: 1000,
            asset_id: 0,
            pk_recipient: [0u8; 32],
            rho: [1u8; 32],
            r: [2u8; 32],
        };

        let output_note = NoteData {
            value: 900,
            asset_id: 0,
            pk_recipient: [3u8; 32],
            rho: [4u8; 32],
            r: [5u8; 32],
        };

        TransactionWitness {
            inputs: vec![InputNoteWitness {
                note: input_note,
                position: 0,
                rho_seed: [7u8; 32],
            }],
            outputs: vec![OutputNoteWitness {
                note: output_note,
            }],
            sk_spend: [6u8; 32],
            merkle_root: BaseElement::new(12345),
            fee: 100,
            version: protocol_versioning::DEFAULT_VERSION_BINDING,
        }
    }

    #[test]
    fn test_verify_valid_proof() {
        let prover = TransactionProverStark::new(fast_proof_options());
        let witness = make_balanced_witness();
        
        let trace = prover.build_trace(&witness).unwrap();
        let pub_inputs = prover.get_public_inputs(&witness);
        
        // Generate proof
        let proof = prover.prove(trace).expect("proving should succeed");
        
        // Verify proof
        let result = verify_transaction_proof(&proof, &pub_inputs);
        assert!(result.is_ok(), "verification should succeed");
    }

    #[test]
    fn test_verify_with_wrong_inputs() {
        let prover = TransactionProverStark::new(fast_proof_options());
        let witness = make_balanced_witness();
        
        let trace = prover.build_trace(&witness).unwrap();
        let mut pub_inputs = prover.get_public_inputs(&witness);
        
        // Generate proof
        let proof = prover.prove(trace).expect("proving should succeed");
        
        // Modify public inputs
        pub_inputs.fee = BaseElement::new(999);
        
        // Verification should fail with wrong inputs
        let result = verify_transaction_proof(&proof, &pub_inputs);
        assert!(result.is_err(), "verification should fail with wrong inputs");
    }

    #[test]
    fn test_verify_with_details() {
        let prover = TransactionProverStark::new(fast_proof_options());
        let witness = make_balanced_witness();
        
        let trace = prover.build_trace(&witness).unwrap();
        let pub_inputs = prover.get_public_inputs(&witness);
        
        let proof = prover.prove(trace).expect("proving should succeed");
        
        let result = verify_with_details(&proof, &pub_inputs);
        assert!(result.valid);
        assert!(result.proof_size > 0);
    }
}
