# Block Header Specification

This document defines the canonical block header layout used by the synthetic hegemonic currency chain. Headers bind post-quantum validator signatures, STARK proof commitments, and Merkle accumulators so that consensus nodes can verify chain progress and state integrity.

## Rationale

The header encapsulates everything a light client or consensus verifier must check before accepting a block:

- **Parent linkage** via the previous block hash to maintain a single hash chain.
- **Execution state** via the note commitment tree root and nullifier set commitment.
- **Proof of correct execution** by including commitments to the STARK proofs generated by the block circuit.
- **Consensus authorization** via ML-DSA signatures from the active validator set (BFT/PoS mode) or PoW seal data (optional mining mode).
- **Metadata** such as height, timestamp, and fork-choice counters that support slashing and liveness guarantees.

## Field Layout

Headers are encoded in little-endian form using the following schema. All fixed-width integers are unsigned unless noted.

| Field | Bytes | Description |
| --- | --- | --- |
| `version` | 4 | Protocol version identifier. Incremented for hard forks. |
| `height` | 8 | Block height counting from 0 (genesis). |
| `view` | 8 | Monotonic consensus view/round number. Used for HotStuff-style quorum certificates and slashing. |
| `timestamp` | 8 | Unix timestamp (milliseconds). Must be within ±10 minutes of validator wall clock. |
| `parent_hash` | 32 | SHA-256 digest of the parent block header. All-zero for genesis. |
| `state_root` | 32 | Commitment to the note Merkle tree root after applying the block. Matches `CommitmentTree::root()`. |
| `nullifier_root` | 32 | Merkle or vector commitment to the nullifier set. Ensures uniqueness enforcement is auditable. |
| `proof_commitment` | 48 | Output of the block STARK circuit commitment (FRI polynomial commitment digest). Sized to 384 bits per circuit spec. |
| `tx_count` | 4 | Number of shielded transactions included. Used for gossip validation and fee accounting. |
| `fee_commitment` | 32 | Hash commitment to aggregate fees per asset (per `balance_tag`). |
| `validator_set_commitment` | 32 | Hash of the validator set metadata used for this block (addresses, stake weights, slashing status). |
| `signature_aggregate` | 3293 | ML-DSA-65 signature over all previous fields plus domain separation tag `b"block"`. Represents either (a) a threshold aggregate in BFT mode, or (b) the block producer’s signature in PoW mode. |
| `signature_bitmap` | variable | Bitset showing which validators contributed to the aggregate. Length = ceil(`N` / 8) for `N` validators. Absent in PoW mode. |
| `pow_nonce` | 32 | Optional field present only in PoW mode. Combined with `pow_target` to prove work. |
| `pow_target` | 4 | Compact difficulty encoding (bits) for PoW blocks. Zeroed in BFT mode. |

### Serialization Order

The canonical encoding concatenates fields in the order listed above. When `pow_target` is zero, the `pow_nonce` is omitted and `signature_bitmap` must be present. When `pow_target` is non-zero, `signature_bitmap` is omitted and `pow_nonce` is appended immediately after `signature_aggregate`.

All hashes are computed using `crypto::hashes::sha256`. The `proof_commitment` width matches the STARK verifier commitment. If future versions change the commitment size, the `version` field and spec must be bumped.

### Signing Procedure

Validators sign the 256-bit hash

```
H_block = sha256(b"block" || encode(header_without_signature_fields))
```

`header_without_signature_fields` includes all fields up to and including `validator_set_commitment`, excluding `signature_aggregate`, `signature_bitmap`, `pow_nonce`, and `pow_target`. Signatures are produced with ML-DSA-65 (Dilithium3). Aggregation uses simple concatenation followed by verification of each signature against the bitmap. A future optimization may adopt multi-signatures, but the initial implementation stores a single aggregate plus bitmap.

### Hashing

The block hash is defined as

```
block_hash = sha256(encode(full_header))
```

Consumers must verify the ML-DSA signature(s) before accepting the hash as valid.

## State Commitments

- `state_root` comes from the append-only note commitment tree in `state/merkle`.
- `nullifier_root` is the root of a binary Merkle tree over sorted nullifiers. Duplicates MUST cause block rejection.
- `fee_commitment` commits to a sorted list of `(asset_id, delta)` tuples as enforced by the transaction circuit balance tag.
- `validator_set_commitment` is the SHA-256 hash of a canonical encoding of `(validator_id, stake, slashed_flag)` tuples sorted by `validator_id`.

## Backwards Compatibility

Genesis blocks omit the signature and instead include a multi-signature from the bootstrap committee stored out-of-band. Nodes treat the first block height as special-cased.

Future upgrades that modify the header must increment `version` and update `DESIGN.md` alongside this spec.

## Security Considerations

- Signatures use domain separation to prevent cross-protocol replay.
- Proof commitments must be verified against the block circuit verifier to ensure transactions satisfy nullifier uniqueness and balance rules.
- Validators must track the `view` number to detect equivocation. Double-signing the same `view` with different `parent_hash` values is slashable.
- In PoW mode, difficulty adjustments rely on the `pow_target` field; only headers with `sha256(encode(full_header)) <= target` are valid. The STARK proof commitment remains mandatory in both modes.
