# Block Header Specification

This document defines the canonical block header layout used by the Hegemon chain. Headers bind STARK proof commitments, Merkle accumulators, and proof-of-work (PoW) seals so that consensus nodes can verify chain progress and state integrity without referencing a validator-set signature scheme.

## Rationale

The header encapsulates everything a light client or consensus verifier must check before accepting a block:

- **Parent linkage** via the previous block hash to maintain a single hash chain.
- **Execution state** via the note commitment tree root and nullifier set commitment.
- **Proof of correct execution** by including commitments to the STARK proofs generated by the block circuit.
- **Consensus authorization** via PoW seal data that proves the miner expended compute to extend the chain.
- **Metadata** such as height, timestamp, and fork-choice counters that support deterministic fork-choice and liveness guarantees.

## Field Layout

Headers are encoded in little-endian form using the following schema. All fixed-width integers are unsigned unless noted.

| Field | Bytes | Description |
| --- | --- | --- |
| `version` | 4 | Protocol version identifier. Incremented for hard forks. |
| `height` | 8 | Block height counting from 0 (genesis). |
| `timestamp` | 8 | Unix timestamp (milliseconds). Must be within Â±10 minutes of the network median time observed by peers. |
| `parent_hash` | 32 | SHA-256 digest of the parent block header. All-zero for genesis. |
| `state_root` | 32 | Commitment to the note Merkle tree root after applying the block. Matches `CommitmentTree::root()`. |
| `nullifier_root` | 32 | Merkle or vector commitment to the nullifier set. Ensures uniqueness enforcement is auditable. |
| `proof_commitment` | 48 | Output of the block STARK circuit commitment (FRI polynomial commitment digest). Sized to 384 bits per circuit spec. |
| `tx_count` | 4 | Number of shielded transactions included. Used for gossip validation and fee accounting. |
| `fee_commitment` | 32 | Hash commitment to aggregate fees per asset (per `balance_tag`). |
| `pow_target` | 4 | Mandatory compact difficulty encoding (bits). Uses Bitcoin-style "nBits" layout (1 byte exponent, 3 byte coefficient). |
| `pow_nonce` | 32 | Mandatory nonce allowing miners to search the header hash space. Little-endian 256-bit integer. |
| `miner_signature` | optional | Optional audit trail proving miner identity (see below). Empty for anonymous mining. |

### Serialization Order

The canonical encoding concatenates fields in the order listed above. `pow_target` and `pow_nonce` are always present. When a miner elects to provide an audit trail, a length-prefixed `miner_signature` follows the nonce:

```
encode(header) = version || height || timestamp || parent_hash || state_root || nullifier_root ||
                 proof_commitment || tx_count || fee_commitment || pow_target || pow_nonce ||
                 opt(len || miner_signature)
```

`pow_target` follows the standard compact format used in Bitcoin headers: the first byte encodes the unsigned exponent `E`, and the remaining three bytes encode a coefficient `C`. The full target is `C * 2^(8*(E-3))`. `pow_nonce` is a 32-byte little-endian integer; miners are free to extend their search space by modifying transaction ordering or `extra_data` within the execution trace, but the header serialization itself is fixed-width to ensure deterministic hashing.

All hashes are computed using `crypto::hashes::sha256`. The `proof_commitment` width matches the STARK verifier commitment. If future versions change the commitment size, the `version` field and spec must be bumped. Likewise, any change to the PoW seal layout requires a version bump to preserve backward compatibility.

### Signing Procedure

PoW security does not require validator-set signatures. Miners may optionally attach an ML-DSA-65 signature covering the same preimage that feeds the PoW hash if they want downstream consumers to attribute work to a known identity. When present, the signature is computed over

```
H_miner = sha256(b"miner" || encode(header_without_miner_signature))
```

where `header_without_miner_signature` stops immediately before the signature length prefix. Nodes treat the signature strictly as metadata; block validity depends only on the PoW target comparison. Implementations SHOULD ignore invalid miner signatures rather than rejecting otherwise valid blocks to maintain liveness.

### Hashing

The block hash is defined as

```
block_hash = sha256(encode(full_header_without_optional_signature))
```

Only the mandatory portion (up through `pow_nonce`) participates in the PoW equation. The optional signature is appended after miners discover a satisfactory nonce so that signature failures cannot be used to malleate the block hash.

## State Commitments

- `state_root` comes from the append-only note commitment tree in `state/merkle`. Miners append newly created notes produced by transaction execution and update the root before finalizing the header.
- `nullifier_root` is the root of a binary Merkle tree over sorted nullifiers. Miners insert all nullifiers revealed by the block's transactions; duplicates MUST cause block rejection.
- `fee_commitment` commits to a sorted list of `(asset_id, delta)` tuples as enforced by the transaction circuit balance tag.

## Backwards Compatibility

Genesis blocks reused the legacy validator-signed format. Full nodes MUST retain the ability to parse both the legacy header (with `validator_set_commitment` and signature data) and the streamlined PoW header for heights <= the cut-over boundary. From the cut-over height onward, headers omit validator material and require populated `pow_target` and `pow_nonce` fields.

Future upgrades that modify the header must increment `version`, update `DESIGN.md` alongside this spec, and provide migration notes covering how miners should serialize headers before hashing.

## Security Considerations

- Optional miner signatures use domain separation to prevent cross-protocol replay while keeping PoW validation decoupled from identity attestations.
- Proof commitments must be verified against the block circuit verifier to ensure transactions satisfy nullifier uniqueness and balance rules.
- Difficulty adjustments rely on the `pow_target` field; only headers with `sha256(encode(full_header_without_optional_signature)) <= target` are valid. The STARK proof commitment remains mandatory.
