#![cfg_attr(not(feature = "std"), no_std)]
#![allow(
    clippy::large_enum_variant,
    clippy::let_unit_value,
    clippy::default_constructed_unit_structs,
    clippy::needless_update,
    clippy::assign_op_pattern,
    clippy::unnecessary_lazy_evaluations,
    deprecated
)]

extern crate alloc;

pub mod apis;

// Include the WASM binary generated by substrate-wasm-builder
// This defines WASM_BINARY and WASM_BINARY_BLOATY
#[cfg(feature = "std")]
include!(concat!(env!("OUT_DIR"), "/wasm_binary.rs"));

use codec::{Decode, DecodeWithMemTracking, Encode, MaxEncodedLen};
use frame_support::traits::{
    ConstU128, ConstU32, ConstU64, ConstU8, Currency as CurrencyTrait, VariantCount,
};
use frame_support::weights::IdentityFee;
use frame_support::BoundedVec;
pub use frame_support::{construct_runtime, parameter_types};
use frame_system as system;
use pallet_attestations::AttestationSettlementEvent;
use scale_info::TypeInfo;
use sp_application_crypto::RuntimeAppPublic;
use sp_core::offchain::StorageKind;
use sp_core::{blake2_256, H256};
use sp_runtime::generic::Era;
use sp_runtime::traits::{
    BlakeTwo256, Convert, Hash as HashT, IdentifyAccount, IdentityLookup, Lazy,
    SaturatedConversion, Verify,
};
use sp_runtime::{
    generic, AccountId32, DispatchError, FixedU128, MultiAddress, Permill, RuntimeDebug,
};
use sp_std::vec::Vec;

mod pq_crypto {
    use super::*;
    use crypto::ml_dsa::{
        MlDsaPublicKey, MlDsaSecretKey, MlDsaSignature, ML_DSA_PUBLIC_KEY_LEN,
        ML_DSA_SECRET_KEY_LEN, ML_DSA_SIGNATURE_LEN,
    };
    use crypto::slh_dsa::{
        SlhDsaPublicKey, SlhDsaSecretKey, SlhDsaSignature, SLH_DSA_PUBLIC_KEY_LEN,
        SLH_DSA_SECRET_KEY_LEN, SLH_DSA_SIGNATURE_LEN,
    };
    use crypto::traits::{SigningKey, VerifyKey};
    use sp_core::crypto::KeyTypeId;
    use sp_io::offchain;
    use sp_runtime::RuntimeDebug;

    const KEY_LIST: &[u8] = b"pq:keys";
    pub const PQ_KEY_TYPE: KeyTypeId = KeyTypeId(*b"pq00");

    // Note: SLH-DSA signatures are ~17KB which exceeds parity-scale-codec's
    // INITIAL_PREALLOCATION of 16KB. We use Box to avoid the inline size issue
    // in Vec<UncheckedExtrinsic> decoding.
    #[derive(Clone, PartialEq, Eq, RuntimeDebug, TypeInfo)]
    pub enum Signature {
        MlDsa {
            signature: [u8; ML_DSA_SIGNATURE_LEN],
            public: Public,
        },
        SlhDsa {
            signature: alloc::boxed::Box<[u8; SLH_DSA_SIGNATURE_LEN]>,
            public: Public,
        },
    }

    // Manual Encode impl to handle Box
    impl codec::Encode for Signature {
        fn encode_to<T: codec::Output + ?Sized>(&self, dest: &mut T) {
            match self {
                Signature::MlDsa { signature, public } => {
                    0u8.encode_to(dest);
                    signature.encode_to(dest);
                    public.encode_to(dest);
                }
                Signature::SlhDsa { signature, public } => {
                    1u8.encode_to(dest);
                    signature.as_ref().encode_to(dest);
                    public.encode_to(dest);
                }
            }
        }
    }

    // Manual Decode impl to handle Box
    impl codec::Decode for Signature {
        fn decode<I: codec::Input>(input: &mut I) -> Result<Self, codec::Error> {
            let variant = u8::decode(input)?;
            match variant {
                0 => {
                    let signature = <[u8; ML_DSA_SIGNATURE_LEN]>::decode(input)?;
                    let public = Public::decode(input)?;
                    Ok(Signature::MlDsa { signature, public })
                }
                1 => {
                    let signature = <[u8; SLH_DSA_SIGNATURE_LEN]>::decode(input)?;
                    let public = Public::decode(input)?;
                    Ok(Signature::SlhDsa { signature: alloc::boxed::Box::new(signature), public })
                }
                _ => Err(codec::Error::from("Invalid Signature variant")),
            }
        }
    }

    // Manual MaxEncodedLen - use the larger variant
    impl codec::MaxEncodedLen for Signature {
        fn max_encoded_len() -> usize {
            1 + SLH_DSA_SIGNATURE_LEN + <Public as codec::MaxEncodedLen>::max_encoded_len()
        }
    }

    impl Signature {
        pub fn signature_bytes(&self) -> &[u8] {
            match self {
                Signature::MlDsa { signature, .. } => signature.as_slice(),
                Signature::SlhDsa { signature, .. } => signature.as_slice(),
            }
        }

        pub fn public(&self) -> &Public {
            match self {
                Signature::MlDsa { public, .. } | Signature::SlhDsa { public, .. } => public,
            }
        }
    }

    impl DecodeWithMemTracking for Signature {}

    #[derive(
        Clone, PartialEq, Eq, PartialOrd, Ord, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen,
    )]
    pub enum Public {
        MlDsa([u8; ML_DSA_PUBLIC_KEY_LEN]),
        SlhDsa([u8; SLH_DSA_PUBLIC_KEY_LEN]),
    }

    impl DecodeWithMemTracking for Public {}

    impl Default for Public {
        fn default() -> Self {
            Public::MlDsa([0u8; ML_DSA_PUBLIC_KEY_LEN])
        }
    }

    // serde impls are unconditional because polkadot-sdk crates (sp-staking, bounded-collections)
    // include serde as a non-optional dependency, activating MaybeSerializeDeserialize bounds
    impl serde::Serialize for Public {
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            serializer.serialize_bytes(self.as_bytes())
        }
    }

    impl<'de> serde::Deserialize<'de> for Public {
        fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            let bytes: alloc::vec::Vec<u8> = serde::Deserialize::deserialize(deserializer)?;
            match bytes.len() {
                ML_DSA_PUBLIC_KEY_LEN => {
                    let arr: [u8; ML_DSA_PUBLIC_KEY_LEN] = bytes
                        .try_into()
                        .map_err(|_| serde::de::Error::custom("ml-dsa length"))?;
                    Ok(Public::MlDsa(arr))
                }
                SLH_DSA_PUBLIC_KEY_LEN => {
                    let arr: [u8; SLH_DSA_PUBLIC_KEY_LEN] = bytes
                        .try_into()
                        .map_err(|_| serde::de::Error::custom("slh-dsa length"))?;
                    Ok(Public::SlhDsa(arr))
                }
                _ => Err(serde::de::Error::custom("unexpected key length")),
            }
        }
    }

    impl Public {
        pub fn as_bytes(&self) -> &[u8] {
            match self {
                Public::MlDsa(bytes) => bytes,
                Public::SlhDsa(bytes) => bytes,
            }
        }
    }

    impl From<MlDsaPublicKey> for Public {
        fn from(key: MlDsaPublicKey) -> Self {
            Public::MlDsa(key.to_bytes().try_into().expect("ml-dsa pk length"))
        }
    }

    impl From<SlhDsaPublicKey> for Public {
        fn from(key: SlhDsaPublicKey) -> Self {
            Public::SlhDsa(key.to_bytes().try_into().expect("slh-dsa pk length"))
        }
    }

    impl IdentifyAccount for Public {
        type AccountId = AccountId32;

        fn into_account(self) -> Self::AccountId {
            // Hash just the raw public key bytes (not the SCALE-encoded enum)
            // This matches how genesis accounts are derived in gen_dev_account.rs
            let hash = BlakeTwo256::hash(self.as_bytes());
            AccountId32::new(hash.into())
        }
    }

    impl Verify for Signature {
        type Signer = Public;

        fn verify<L: Lazy<[u8]>>(&self, mut msg: L, signer: &AccountId32) -> bool {
            let public = self.public();
            if public.clone().into_account() != *signer {
                return false;
            }

            match self {
                Signature::MlDsa { signature, public } => {
                    let Ok(public) = MlDsaPublicKey::from_bytes(public.as_bytes()) else {
                        return false;
                    };
                    let Ok(signature) = MlDsaSignature::from_bytes(signature) else {
                        return false;
                    };
                    public.verify(msg.get(), &signature).is_ok()
                }
                Signature::SlhDsa { signature, public } => {
                    let Ok(public) = SlhDsaPublicKey::from_bytes(public.as_bytes()) else {
                        return false;
                    };
                    let Ok(signature) = SlhDsaSignature::from_bytes(signature.as_ref()) else {
                        return false;
                    };
                    public.verify(msg.get(), &signature).is_ok()
                }
            }
        }
    }

    #[derive(Clone, PartialEq, Eq, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen)]
    pub struct PqAppPublic(pub Public);

    #[derive(Clone, PartialEq, Eq, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen)]
    enum StoredSecret {
        MlDsa([u8; ML_DSA_SECRET_KEY_LEN]),
        SlhDsa([u8; SLH_DSA_SECRET_KEY_LEN]),
    }

    impl PqAppPublic {
        fn secret_key(public: &Public) -> Vec<u8> {
            let mut key = b"pq:sk".to_vec();
            key.extend_from_slice(&blake2_256(public.as_bytes()));
            key
        }

        fn load_secrets() -> Vec<Public> {
            offchain::local_storage_get(StorageKind::PERSISTENT, KEY_LIST)
                .and_then(|raw| Vec::<Public>::decode(&mut raw.as_slice()).ok())
                .unwrap_or_default()
        }

        fn store_secrets(keys: &[Public]) {
            let encoded = keys.encode();
            offchain::local_storage_set(StorageKind::PERSISTENT, KEY_LIST, &encoded);
        }

        fn store_secret(public: &Public, secret: StoredSecret) {
            let key = Self::secret_key(public);
            let encoded = secret.encode();
            offchain::local_storage_set(StorageKind::PERSISTENT, &key, &encoded);
        }

        fn load_secret(public: &Public) -> Option<StoredSecret> {
            let key = Self::secret_key(public);
            offchain::local_storage_get(StorageKind::PERSISTENT, &key)
                .and_then(|raw| StoredSecret::decode(&mut raw.as_slice()).ok())
        }
    }

    impl RuntimeAppPublic for PqAppPublic {
        const ID: KeyTypeId = PQ_KEY_TYPE;

        type Signature = Signature;
        type ProofOfPossession = Signature;

        fn all() -> Vec<Self> {
            Self::load_secrets().into_iter().map(PqAppPublic).collect()
        }

        fn generate_pair(seed: Option<Vec<u8>>) -> Self {
            let seed_material = seed.unwrap_or_else(|| offchain::random_seed().to_vec());
            let secret = MlDsaSecretKey::generate_deterministic(&seed_material);
            let public = secret.verify_key();
            let public: Public = public.into();
            let stored = StoredSecret::MlDsa(secret.to_bytes().try_into().expect("ml-dsa sk len"));

            let mut keys = Self::load_secrets();
            if !keys.contains(&public) {
                keys.push(public.clone());
                Self::store_secrets(&keys);
            }
            Self::store_secret(&public, stored);
            PqAppPublic(public)
        }

        fn sign<M: AsRef<[u8]>>(&self, msg: &M) -> Option<Self::Signature> {
            let public = self.0.clone();
            let secret = Self::load_secret(&public)?;
            match secret {
                StoredSecret::MlDsa(bytes) => {
                    let secret = MlDsaSecretKey::from_bytes(&bytes).ok()?;
                    let signature_vec = secret.sign(msg.as_ref()).to_bytes();
                    let signature: [u8; ML_DSA_SIGNATURE_LEN] = signature_vec.try_into().ok()?;
                    Some(Signature::MlDsa { signature, public })
                }
                StoredSecret::SlhDsa(bytes) => {
                    let secret = SlhDsaSecretKey::from_bytes(&bytes).ok()?;
                    let signature_vec = secret.sign(msg.as_ref()).to_bytes();
                    let signature: [u8; SLH_DSA_SIGNATURE_LEN] = signature_vec.try_into().ok()?;
                    Some(Signature::SlhDsa { signature: alloc::boxed::Box::new(signature), public })
                }
            }
        }

        fn verify<M: AsRef<[u8]>>(&self, msg: &M, signature: &Self::Signature) -> bool {
            let account = self.0.clone().into_account();
            signature.verify(msg.as_ref(), &account)
        }

        fn generate_proof_of_possession(&mut self, context: &[u8]) -> Option<Self::ProofOfPossession> {
            // Proof of possession: sign the public key bytes concatenated with context
            let mut msg = self.0.as_bytes().to_vec();
            msg.extend_from_slice(context);
            self.sign(&msg)
        }

        fn verify_proof_of_possession(&self, context: &[u8], pop: &Self::ProofOfPossession) -> bool {
            let mut msg = self.0.as_bytes().to_vec();
            msg.extend_from_slice(context);
            self.verify(&msg, pop)
        }

        fn to_raw_vec(&self) -> Vec<u8> {
            self.0.as_bytes().to_vec()
        }
    }

    impl From<Public> for PqAppPublic {
        fn from(value: Public) -> Self {
            PqAppPublic(value)
        }
    }

    impl From<PqAppPublic> for Public {
        fn from(value: PqAppPublic) -> Self {
            value.0
        }
    }

    pub struct PqAppCrypto;

    impl frame_system::offchain::AppCrypto<Public, Signature> for PqAppCrypto {
        type RuntimeAppPublic = PqAppPublic;
        type GenericPublic = Public;
        type GenericSignature = Signature;
    }
}

pub use pq_crypto::{
    PqAppCrypto, PqAppPublic, Public as PqPublic, Signature as PqSignature, PQ_KEY_TYPE,
};

pub type BlockNumber = u64;
pub type Signature = pq_crypto::Signature;
pub type Public = pq_crypto::Public;
pub type AccountId = <Public as IdentifyAccount>::AccountId;
pub type Balance = u128;
pub type Index = u64;
pub type Hash = H256;
pub type Moment = u64;

pub type Address = MultiAddress<AccountId, ()>;
pub type Header = generic::Header<BlockNumber, BlakeTwo256>;
pub type UncheckedExtrinsic =
    generic::UncheckedExtrinsic<Address, RuntimeCall, Signature, SignedExtra>;
pub type Block = generic::Block<Header, UncheckedExtrinsic>;

type SignedExtra = (
    frame_system::CheckNonZeroSender<Runtime>,
    frame_system::CheckSpecVersion<Runtime>,
    frame_system::CheckTxVersion<Runtime>,
    frame_system::CheckGenesis<Runtime>,
    frame_system::CheckEra<Runtime>,
    frame_system::CheckNonce<Runtime>,
    frame_system::CheckWeight<Runtime>,
    pallet_transaction_payment::ChargeTransactionPayment<Runtime>,
);

type SignedPayload = sp_runtime::generic::SignedPayload<RuntimeCall, SignedExtra>;

#[derive(Clone, Copy, Encode, Decode, PartialEq, Eq, RuntimeDebug, MaxEncodedLen, TypeInfo)]
pub enum HoldReason {
    FeeModel,
    Session,
}

impl VariantCount for HoldReason {
    const VARIANT_COUNT: u32 = 2;
}

impl DecodeWithMemTracking for HoldReason {}

impl From<pallet_session::HoldReason> for HoldReason {
    fn from(_: pallet_session::HoldReason) -> Self {
        HoldReason::Session
    }
}

parameter_types! {
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxDidDocLength: u32 = 128;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxSchemaLength: u32 = 128;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxProofSize: u32 = 64;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxIdentityTags: u32 = 8;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxTagLength: u32 = 32;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxPqKeyBytes: u32 = 4000;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxMetadataLength: u32 = 128;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxTagsPerAsset: u32 = 8;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxProvenanceRefs: u32 = 4;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxFeeds: u32 = 16;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxFeedName: u32 = 64;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxEndpoint: u32 = 128;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxCommitmentSize: u32 = 256;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxPendingIngestions: u32 = 8;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxPendingRewards: u32 = 32;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxPowValidators: u32 = 256;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxRootSize: u32 = 64;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxVerificationKeySize: u32 = 64;
    #[derive(Clone, Copy, PartialEq, Eq, Debug, TypeInfo)]
    pub const MaxPendingEvents: u32 = 8;
}

#[derive(
    Clone,
    Encode,
    Decode,
    DecodeWithMemTracking,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    RuntimeDebug,
    MaxEncodedLen,
    TypeInfo,
)]
pub struct IssuerId(pub AccountId);

impl Default for IssuerId {
    fn default() -> Self {
        IssuerId(AccountId::new([0u8; 32]))
    }
}

impl From<AccountId> for IssuerId {
    fn from(account: AccountId) -> Self {
        IssuerId(account)
    }
}

impl From<IssuerId> for AccountId {
    fn from(value: IssuerId) -> Self {
        value.0
    }
}

pub struct AccountIdAsValidatorId;
impl Convert<AccountId, Option<AccountId>> for AccountIdAsValidatorId {
    fn convert(account: AccountId) -> Option<AccountId> {
        Some(account)
    }
}

// serde impls are unconditional because polkadot-sdk crates require it
#[derive(Clone, Default, Encode, Decode, PartialEq, Eq, RuntimeDebug, MaxEncodedLen, TypeInfo, serde::Serialize, serde::Deserialize)]
pub struct DummySessionKeys;

impl sp_runtime::traits::OpaqueKeys for DummySessionKeys {
    type KeyTypeIdProviders = ();

    fn key_ids() -> &'static [sp_core::crypto::KeyTypeId] {
        &[]
    }

    fn get_raw(&self, _i: sp_core::crypto::KeyTypeId) -> &[u8] {
        &[]
    }
}

impl DummySessionKeys {
    /// Generate session keys - no-op for dummy implementation
    pub fn generate(_seed: Option<Vec<u8>>) -> Vec<u8> {
        Self::default().encode()
    }

    /// Decode session keys into raw public keys - no-op for dummy implementation
    pub fn decode_into_raw_public_keys(
        encoded: &[u8],
    ) -> Option<Vec<(Vec<u8>, sp_core::crypto::KeyTypeId)>> {
        let _ = Self::decode(&mut &encoded[..]).ok()?;
        Some(Vec::new())
    }
}

impl DecodeWithMemTracking for DummySessionKeys {}

pub struct NullSessionHandler;

impl pallet_session::SessionHandler<AccountId> for NullSessionHandler {
    const KEY_TYPE_IDS: &'static [sp_core::crypto::KeyTypeId] = &[];

    fn on_genesis_session<Ks: sp_runtime::traits::OpaqueKeys>(_validators: &[(AccountId, Ks)]) {}

    fn on_new_session<Ks: sp_runtime::traits::OpaqueKeys>(
        _changed: bool,
        _validators: &[(AccountId, Ks)],
        _queued_validators: &[(AccountId, Ks)],
    ) {
    }

    fn on_before_session_ending() {}

    fn on_disabled(_validator_index: u32) {}
}

pub struct TreasurySpendLimit;
impl frame_support::traits::TypedGet for TreasurySpendLimit {
    type Type = Balance;

    fn get() -> Self::Type {
        Balance::MAX
    }
}

pub struct RootAccount;
impl frame_support::traits::TypedGet for RootAccount {
    type Type = AccountId;

    fn get() -> Self::Type {
        AccountId::new([0u8; 32])
    }
}

pub struct RuntimeTreasurySpendFunds;
impl pallet_treasury::SpendFunds<Runtime> for RuntimeTreasurySpendFunds {
    fn spend_funds(
        _budget_remaining: &mut pallet_treasury::BalanceOf<Runtime>,
        _imbalance: &mut pallet_treasury::PositiveImbalanceOf<Runtime>,
        _total_weight: &mut frame_support::weights::Weight,
        _missed_any: &mut bool,
    ) {
    }
}

#[derive(Clone, Default, Encode, Decode, PartialEq, Eq, RuntimeDebug, MaxEncodedLen, TypeInfo)]
pub struct NoConsideration;

impl<A, F> frame_support::traits::Consideration<A, F> for NoConsideration {
    fn new(_: &A, _: F) -> Result<Self, DispatchError> {
        Ok(NoConsideration)
    }

    fn update(self, _: &A, _: F) -> Result<Self, DispatchError> {
        Ok(self)
    }

    fn drop(self, _: &A) -> Result<(), DispatchError> {
        Ok(())
    }

    #[cfg(feature = "runtime-benchmarks")]
    fn ensure_successful(_: &A, _: F) {}
}

impl<A, F> frame_support::traits::MaybeConsideration<A, F> for NoConsideration {
    fn is_none(&self) -> bool {
        true
    }
}

impl DecodeWithMemTracking for NoConsideration {}

pub struct MaxCollectiveProposalWeight;
impl frame_support::traits::Get<frame_support::weights::Weight> for MaxCollectiveProposalWeight {
    fn get() -> frame_support::weights::Weight {
        frame_support::weights::Weight::MAX
    }
}

#[frame_support::pallet]
#[allow(deprecated)]
pub mod pow {
    use super::{Moment, PowDifficulty, PowFutureDrift, PowRetargetWindow, PowTargetBlockTime};
    use crate::MaxPowValidators;
    use alloc::vec::Vec;
    use frame_support::{pallet_prelude::*, BoundedVec};
    use frame_system::pallet_prelude::*;
    use sp_core::{H256, U256};
    use sp_staking::SessionIndex;

    #[pallet::config]
    #[allow(deprecated)]
    pub trait Config: frame_system::Config + pallet_timestamp::Config<Moment = Moment> {
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
    }

    #[pallet::pallet]
    pub struct Pallet<T>(_);

    #[pallet::type_value]
    pub fn DefaultDifficulty<T: Config>() -> u32 {
        PowDifficulty::get()
    }

    #[pallet::type_value]
    pub fn DefaultTimestampQueue() -> BoundedVec<Moment, PowRetargetWindow> {
        BoundedVec::default()
    }

    #[pallet::storage]
    #[pallet::getter(fn difficulty)]
    pub type Difficulty<T: Config> = StorageValue<_, u32, ValueQuery, DefaultDifficulty<T>>;

    #[pallet::storage]
    #[pallet::getter(fn recent_timestamps)]
    pub type RecentTimestamps<T: Config> =
        StorageValue<_, BoundedVec<Moment, PowRetargetWindow>, ValueQuery, DefaultTimestampQueue>;

    #[pallet::storage]
    #[pallet::getter(fn validators)]
    pub type Validators<T: Config> =
        StorageValue<_, BoundedVec<T::AccountId, MaxPowValidators>, ValueQuery>;

    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        PowBlockImported {
            author: T::AccountId,
            pow_bits: u32,
            nonce: u64,
        },
        PowInvalidSeal {
            pow_bits: u32,
            nonce: u64,
        },
        SessionValidatorsRotated {
            session: SessionIndex,
            validators: Vec<T::AccountId>,
        },
    }

    #[pallet::error]
    pub enum Error<T> {
        InsufficientWork,
        UnexpectedDifficulty,
        FutureTimestamp,
    }

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        #[pallet::call_index(0)]
        #[allow(deprecated)]
        #[pallet::weight(10_000)]
        pub fn submit_work(
            origin: OriginFor<T>,
            pre_hash: H256,
            nonce: u64,
            pow_bits: u32,
            timestamp: Moment,
        ) -> DispatchResult {
            let who = ensure_signed(origin)?;
            let expected_bits = Difficulty::<T>::get();
            ensure!(pow_bits == expected_bits, Error::<T>::UnexpectedDifficulty);
            let now = pallet_timestamp::Pallet::<T>::get();
            ensure!(
                timestamp <= now + PowFutureDrift::get(),
                Error::<T>::FutureTimestamp
            );
            let valid = Self::seal_meets_target(pre_hash, nonce, pow_bits);
            if !valid {
                Self::deposit_event(Event::PowInvalidSeal { pow_bits, nonce });
                return Err(Error::<T>::InsufficientWork.into());
            }

            Self::note_timestamp(timestamp)?;
            Self::note_validator(who.clone());
            Self::deposit_event(Event::PowBlockImported {
                author: who,
                pow_bits,
                nonce,
            });
            Ok(())
        }
    }

    impl<T: Config> Pallet<T> {
        fn seal_meets_target(pre_hash: H256, nonce: u64, pow_bits: u32) -> bool {
            let mut data = pre_hash.as_bytes().to_vec();
            data.extend_from_slice(&nonce.to_le_bytes());
            let hash = sp_io::hashing::blake2_256(&data);
            let hash_u256 = U256::from_big_endian(&hash);
            if let Some(target) = Self::compact_to_target(pow_bits) {
                hash_u256 <= target
            } else {
                false
            }
        }

        fn compact_to_target(bits: u32) -> Option<U256> {
            let exponent = bits >> 24;
            let mantissa = bits & 0x00ff_ffff;
            if mantissa == 0 {
                return None;
            }
            if exponent > 32 {
                return Some(U256::MAX);
            }
            let mut target = U256::from(mantissa);
            if exponent > 3 {
                target <<= 8 * (exponent - 3);
            } else {
                target >>= 8 * (3 - exponent);
            }
            Some(target)
        }

        fn target_to_compact(target: U256) -> u32 {
            if target.is_zero() {
                return 0;
            }
            let bytes = target.to_big_endian();
            let mut exponent = 32u32;
            while exponent > 0 && bytes[32 - exponent as usize] == 0 {
                exponent -= 1;
            }
            let start = 32 - exponent as usize;
            let mantissa = ((bytes[start] as u32) << 16)
                | ((bytes.get(start + 1).copied().unwrap_or(0) as u32) << 8)
                | (bytes.get(start + 2).copied().unwrap_or(0) as u32);
            (exponent << 24) | (mantissa & 0x00ff_ffff)
        }

        fn retarget(prev_bits: u32, timestamps: &BoundedVec<Moment, PowRetargetWindow>) -> u32 {
            if timestamps.len() < 2 {
                return prev_bits;
            }
            let expected_span = PowTargetBlockTime::get()
                .saturating_mul((timestamps.len() as u64).saturating_sub(1));
            let actual = timestamps
                .last()
                .copied()
                .unwrap_or_default()
                .saturating_sub(timestamps.first().copied().unwrap_or_default());
            let clamped = actual.clamp(expected_span / 4, expected_span * 4);
            let prev_target = Self::compact_to_target(prev_bits).unwrap_or_default();
            if prev_target.is_zero() || expected_span == 0 {
                return prev_bits;
            }
            let mut target = prev_target.saturating_mul(U256::from(clamped));
            target /= U256::from(expected_span);
            Self::target_to_compact(target)
        }

        fn note_timestamp(timestamp: Moment) -> DispatchResult {
            RecentTimestamps::<T>::try_mutate(|queue| {
                queue
                    .try_push(timestamp)
                    .map_err(|_| Error::<T>::FutureTimestamp)?;
                if queue.len() as u32 == PowRetargetWindow::get() {
                    let current = Difficulty::<T>::get();
                    let new_bits = Self::retarget(current, queue);
                    Difficulty::<T>::put(new_bits);
                    queue.clear();
                }
                Ok(())
            })
        }

        fn note_validator(account: T::AccountId) {
            let _ = Validators::<T>::try_mutate(|vals| {
                if !vals.contains(&account) {
                    let _ = vals.try_push(account);
                }
                Ok::<(), ()>(())
            });
        }
    }

    impl<T: Config> pallet_session::SessionManager<T::AccountId> for Pallet<T> {
        fn new_session(index: SessionIndex) -> Option<Vec<T::AccountId>> {
            let validators = Validators::<T>::get();
            if validators.is_empty() {
                None
            } else {
                let set = validators.to_vec();
                Pallet::<T>::deposit_event(Event::SessionValidatorsRotated {
                    session: index,
                    validators: set.clone(),
                });
                Some(set)
            }
        }

        fn end_session(_index: SessionIndex) {}

        fn start_session(_index: SessionIndex) {}
    }
}

/// Runtime version used in impl_runtime_apis! and version() returns
pub const VERSION: sp_version::RuntimeVersion = sp_version::RuntimeVersion {
    spec_name: sp_runtime::create_runtime_str!("synthetic-hegemonic"),
    impl_name: sp_runtime::create_runtime_str!("synthetic-hegemonic"),
    authoring_version: 1,
    spec_version: 2,
    impl_version: 1,
    apis: RUNTIME_API_VERSIONS,
    transaction_version: 1,
    system_version: 0,
};

parameter_types! {
    pub const BlockHashCount: u64 = 250;
    #[allow(deprecated)]
    pub const Version: sp_version::RuntimeVersion = VERSION;
    pub const SS58Prefix: u16 = 42;
    pub const MinimumPeriod: u64 = 5;
    pub const ExistentialDeposit: u128 = 1;
    pub const MaxLocks: u32 = 50;
    pub const SessionPeriod: u64 = 10;
    pub const SessionOffset: u64 = 0;
    pub const TreasuryPayoutPeriod: u64 = 10;
    pub const PowDifficulty: u32 = 0x3f00_ffff;
    pub const PowRetargetWindow: u32 = 120;
    pub const PowTargetBlockTime: Moment = 20_000;
    pub const PowFutureDrift: Moment = 90_000;
}

impl system::Config for Runtime {
    type BaseCallFilter = frame_support::traits::Everything;
    type BlockWeights = ();
    type BlockLength = ();
    type DbWeight = frame_support::weights::constants::RocksDbWeight;
    type RuntimeOrigin = RuntimeOrigin;
    type RuntimeCall = RuntimeCall;
    type RuntimeTask = ();
    type Nonce = Index;
    type Hash = Hash;
    type Hashing = BlakeTwo256;
    type AccountId = AccountId;
    type Lookup = sp_runtime::traits::AccountIdLookup<AccountId, ()>;
    type Block = Block;
    type RuntimeEvent = RuntimeEvent;
    type BlockHashCount = BlockHashCount;
    type Version = Version;
    type PalletInfo = PalletInfo;
    type AccountData = pallet_balances::AccountData<Balance>;
    type OnNewAccount = ();
    type OnKilledAccount = ();
    type SystemWeightInfo = ();
    type ExtensionsWeightInfo = ();
    type SS58Prefix = SS58Prefix;
    type OnSetCode = ();
    type MaxConsumers = ConstU32<16>;
    type SingleBlockMigrations = ();
    type MultiBlockMigrator = ();
    type PreInherents = ();
    type PostInherents = ();
    type PostTransactions = ();
}

impl pallet_timestamp::Config for Runtime {
    type Moment = Moment;
    type OnTimestampSet = ();
    type MinimumPeriod = MinimumPeriod;
    type WeightInfo = ();
}

#[allow(deprecated)]
impl pow::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
}

impl frame_system::offchain::SigningTypes for Runtime {
    type Public = <Signature as Verify>::Signer;
    type Signature = Signature;
}

impl<LocalCall> frame_system::offchain::CreateTransactionBase<LocalCall> for Runtime
where
    RuntimeCall: From<LocalCall>,
{
    type Extrinsic = UncheckedExtrinsic;
    type RuntimeCall = RuntimeCall;
}

impl<LocalCall> frame_system::offchain::CreateSignedTransaction<LocalCall> for Runtime
where
    RuntimeCall: From<LocalCall>,
{
    fn create_signed_transaction<
        C: frame_system::offchain::AppCrypto<Self::Public, Self::Signature>,
    >(
        call: RuntimeCall,
        public: <Self as frame_system::offchain::SigningTypes>::Public,
        account: AccountId,
        nonce: Index,
    ) -> Option<UncheckedExtrinsic> {
        let tip = 0;
        let period = 64;
        let current_block = System::block_number()
            .saturated_into::<u64>()
            .saturating_sub(1);
        let era = Era::mortal(period, current_block);
        let extra: SignedExtra = (
            frame_system::CheckNonZeroSender::<Runtime>::new(),
            frame_system::CheckSpecVersion::<Runtime>::new(),
            frame_system::CheckTxVersion::<Runtime>::new(),
            frame_system::CheckGenesis::<Runtime>::new(),
            frame_system::CheckEra::<Runtime>::from(era),
            frame_system::CheckNonce::<Runtime>::from(nonce),
            frame_system::CheckWeight::<Runtime>::new(),
            pallet_transaction_payment::ChargeTransactionPayment::<Runtime>::from(tip),
        );

        let raw_payload = SignedPayload::new(call, extra).ok()?;
        let signature = raw_payload.using_encoded(|payload| C::sign(payload, public.clone()))?;
        let address = MultiAddress::Id(account);
        let (call, extra, _) = raw_payload.deconstruct();
        Some(UncheckedExtrinsic::new_signed(
            call, address, signature, extra,
        ))
    }
}

impl pallet_session::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type ValidatorId = AccountId;
    type ValidatorIdOf = AccountIdAsValidatorId;
    type ShouldEndSession = pallet_session::PeriodicSessions<SessionPeriod, SessionOffset>;
    type NextSessionRotation = pallet_session::PeriodicSessions<SessionPeriod, SessionOffset>;
    type SessionManager = pow::Pallet<Runtime>;
    type SessionHandler = NullSessionHandler;
    type Keys = DummySessionKeys;
    type DisablingStrategy = ();
    type Currency = Balances;
    type KeyDeposit = ConstU128<0>;
    type WeightInfo = ();
}

impl pallet_balances::Config for Runtime {
    type Balance = Balance;
    type DustRemoval = ();
    type RuntimeEvent = RuntimeEvent;
    type ExistentialDeposit = ExistentialDeposit;
    type AccountStore = System;
    type WeightInfo = ();
    type RuntimeHoldReason = HoldReason;
    type RuntimeFreezeReason = ();
    type MaxReserves = ConstU32<16>;
    type ReserveIdentifier = [u8; 8];
    type MaxLocks = MaxLocks;
    type FreezeIdentifier = [u8; 8];
    type MaxFreezes = ConstU32<0>;
    type DoneSlashHandler = ();
}

type NegativeImbalance = <Balances as CurrencyTrait<AccountId>>::NegativeImbalance;

pub struct RuntimeFeeCollector;
impl frame_support::traits::OnUnbalanced<NegativeImbalance> for RuntimeFeeCollector {
    fn on_nonzero_unbalanced(_amount: NegativeImbalance) {}
}

pub struct RuntimeCallClassifier;
impl pallet_fee_model::CallClassifier<RuntimeCall> for RuntimeCallClassifier {
    fn classify(_call: &RuntimeCall) -> pallet_fee_model::CallCategory {
        pallet_fee_model::CallCategory::Attestation
    }
}

pub struct RuntimeIdentityProvider;
impl pallet_fee_model::FeeTagProvider<AccountId, pallet_identity::pallet::IdentityTag<Runtime>>
    for RuntimeIdentityProvider
{
    fn tags(account: &AccountId) -> Vec<pallet_identity::pallet::IdentityTag<Runtime>> {
        pallet_identity::Pallet::<Runtime>::identity_tags_for(account)
    }
}

impl pallet_transaction_payment::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type OnChargeTransaction = pallet_fee_model::FeeModelOnCharge<Runtime, RuntimeFeeCollector>;
    type OperationalFeeMultiplier = ConstU8<1>;
    type WeightToFee = IdentityFee<Balance>;
    type LengthToFee = IdentityFee<Balance>;
    type FeeMultiplierUpdate = ();
    type WeightInfo = ();
}

impl pallet_sudo::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type RuntimeCall = RuntimeCall;
    type WeightInfo = ();
}

impl pallet_collective::Config<pallet_collective::Instance1> for Runtime {
    type RuntimeOrigin = RuntimeOrigin;
    type Proposal = RuntimeCall;
    type RuntimeEvent = RuntimeEvent;
    type MotionDuration = ConstU64<5>;
    type MaxProposals = ConstU32<10>;
    type MaxMembers = ConstU32<10>;
    type DefaultVote = pallet_collective::PrimeDefaultVote;
    type WeightInfo = ();
    type SetMembersOrigin = frame_system::EnsureRoot<AccountId>;
    type MaxProposalWeight = MaxCollectiveProposalWeight;
    type DisapproveOrigin = frame_system::EnsureRoot<AccountId>;
    type KillOrigin = frame_system::EnsureRoot<AccountId>;
    type Consideration = NoConsideration;
}

type CouncilCollective = pallet_collective::Instance1;
type CouncilApprovalOrigin =
    pallet_collective::EnsureProportionAtLeast<AccountId, CouncilCollective, 1, 2>;
type ReferendaOrigin = frame_system::EnsureRoot<AccountId>;

impl pallet_membership::Config<pallet_membership::Instance1> for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type AddOrigin = frame_system::EnsureRoot<AccountId>;
    type RemoveOrigin = frame_system::EnsureRoot<AccountId>;
    type SwapOrigin = frame_system::EnsureRoot<AccountId>;
    type ResetOrigin = frame_system::EnsureRoot<AccountId>;
    type PrimeOrigin = frame_system::EnsureRoot<AccountId>;
    type MembershipInitialized = Council;
    type MembershipChanged = Council;
    type MaxMembers = ConstU32<10>;
    type WeightInfo = ();
}

parameter_types! {
    pub const TreasuryPalletId: frame_support::PalletId = frame_support::PalletId(*b"py/trsry");
    pub const TreasuryBurn: Permill = Permill::zero();
}

impl pallet_treasury::Config for Runtime {
    type PalletId = TreasuryPalletId;
    type Currency = Balances;
    type RejectOrigin = frame_system::EnsureRoot<AccountId>;
    type RuntimeEvent = RuntimeEvent;
    type SpendPeriod = TreasuryPayoutPeriod;
    type Burn = TreasuryBurn;
    type BurnDestination = (); // burn
    type SpendFunds = RuntimeTreasurySpendFunds;
    type MaxApprovals = ConstU32<100>;
    type WeightInfo = ();
    type SpendOrigin = frame_system::EnsureRootWithSuccess<AccountId, TreasurySpendLimit>;
    type AssetKind = (); // unused
    type Beneficiary = AccountId;
    type BeneficiaryLookup = IdentityLookup<AccountId>;
    type Paymaster = frame_support::traits::tokens::PayFromAccount<
        Balances,
        pallet_treasury::TreasuryAccountId<Runtime>,
    >;
    type BalanceConverter = frame_support::traits::tokens::UnityAssetBalanceConversion;
    type PayoutPeriod = TreasuryPayoutPeriod;
    type BlockNumberProvider = System;
}

parameter_types! {
    pub const FeedRegistrarRole: u32 = 7;
    pub const FeedSubmitterCredential: u32 = 77;
    pub const FeedVerifierRole: u32 = 8;
    pub const OracleReward: Balance = 10;
    pub const ValidatorReward: Balance = 5;
}

impl pallet_oracles::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type FeedId = u32;
    type RoleId = u32;
    type CredentialSchemaId = u32;
    type IdentityTag = pallet_identity::pallet::IdentityTag<Runtime>;
    type Identity = pallet_identity::Pallet<Runtime>;
    type AttestationId = u32;
    type OffchainIngestion = ();
    type AttestationAuditor = ();
    type FeedRegistrarRole = FeedRegistrarRole;
    type FeedSubmitterCredential = FeedSubmitterCredential;
    type FeedVerifierRole = FeedVerifierRole;
    type MaxFeeds = MaxFeeds;
    type MaxFeedName = MaxFeedName;
    type MaxEndpoint = MaxEndpoint;
    type MaxCommitmentSize = MaxCommitmentSize;
    type MaxPendingIngestions = MaxPendingIngestions;
    type Currency = Balances;
    type MaxPendingRewards = MaxPendingRewards;
    type OracleReward = OracleReward;
    type ValidatorReward = ValidatorReward;
    type WeightInfo = pallet_oracles::DefaultWeightInfo;
}

parameter_types! {
    pub const DefaultAttestationVerifierParams: pallet_attestations::StarkVerifierParams =
        pallet_attestations::StarkVerifierParams {
            hash: pallet_attestations::StarkHashFunction::Blake3,
            fri_queries: 28,
            blowup_factor: 4,
            security_bits: 128,
        };
    pub const DefaultSettlementVerifierParams: pallet_settlement::StarkVerifierParams =
        pallet_settlement::StarkVerifierParams {
            hash: pallet_settlement::StarkHashFunction::Blake3,
            fri_queries: 28,
            blowup_factor: 4,
            security_bits: 128,
        };
}

#[derive(Clone, Copy, Default)]
pub struct RuntimeAttestationBridge;

impl RuntimeAttestationBridge {
    fn parse_commitment(payload: &[u8]) -> Result<u64, DispatchError> {
        let bytes: [u8; 8] = payload
            .get(0..8)
            .ok_or(DispatchError::Other("payload-too-short"))?
            .try_into()
            .map_err(|_| DispatchError::Other("payload-size"))?;
        Ok(u64::from_le_bytes(bytes))
    }
}

impl pallet_identity::ExternalAttestation<AccountId, u32, u32> for RuntimeAttestationBridge {
    fn validate_attestation(
        issuer: &AccountId,
        subject: &AccountId,
        _schema: &u32,
        payload: &[u8],
    ) -> frame_support::dispatch::DispatchResult {
        let commitment = Self::parse_commitment(payload)?;
        let asset_id: u32 = (commitment % u64::from(u32::MAX)) as u32;
        if !pallet_asset_registry::Assets::<Runtime>::contains_key(asset_id) {
            let metadata = BoundedVec::<u8, MaxMetadataLength>::default();
            let tags: pallet_asset_registry::DefaultTagSet<Runtime> = Default::default();
            let provenance: DefaultProvenanceRefs = Default::default();
            let details = pallet_asset_registry::AssetDetails::new(
                issuer.clone(),
                metadata,
                tags,
                provenance,
                system::Pallet::<Runtime>::block_number(),
            );
            pallet_asset_registry::Assets::<Runtime>::insert(asset_id, details);
        }
        // identity must exist, ensure subject known
        let _ = subject;
        Ok(())
    }

    fn on_credential_issued(issuer: &AccountId, subject: &AccountId, schema: &u32, _roles: &[u32]) {
        let payload = schema.to_le_bytes();
        if let Ok(commitment) = Self::parse_commitment(&payload) {
            let _ = pallet_attestations::PendingSettlementEvents::<Runtime>::try_mutate(|events| {
                let event = AttestationSettlementEvent {
                    commitment_id: commitment,
                    stage: pallet_attestations::SettlementStage::Submitted,
                    issuer: Some(issuer.clone().into()),
                    dispute: pallet_attestations::DisputeStatus::None,
                    block_number: system::Pallet::<Runtime>::block_number(),
                };
                events.try_push(event)
            });
            let _ = pallet_settlement::PendingQueue::<Runtime>::try_mutate(|queue| {
                queue.try_push(commitment)
            });
            let _ = subject;
        }
    }

    fn on_credential_revoked(_issuer: &AccountId, _subject: &AccountId, schema: &u32) {
        let payload = schema.to_le_bytes();
        if let Ok(commitment) = Self::parse_commitment(&payload) {
            let _ = pallet_attestations::PendingSettlementEvents::<Runtime>::try_mutate(|events| {
                events.retain(|evt| evt.commitment_id != commitment);
                events.try_push(AttestationSettlementEvent {
                    commitment_id: commitment,
                    stage: pallet_attestations::SettlementStage::RolledBack,
                    issuer: None,
                    dispute: pallet_attestations::DisputeStatus::RolledBack,
                    block_number: system::Pallet::<Runtime>::block_number(),
                })
            });
            pallet_settlement::PendingQueue::<Runtime>::mutate(|queue| {
                queue.retain(|id| id != &commitment)
            });
        }
    }
}

impl pallet_identity::CredentialProofVerifier<AccountId, u32> for RuntimeAttestationBridge {}

impl pallet_identity::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type AuthorityId = Public;
    type CredentialSchemaId = u32;
    type RoleId = u32;
    type AdminOrigin = frame_system::EnsureRootWithSuccess<AccountId, RootAccount>;
    type ExternalAttestation = RuntimeAttestationBridge;
    type CredentialProofVerifier = RuntimeAttestationBridge;
    type MaxDidDocLength = MaxDidDocLength;
    type MaxSchemaLength = MaxSchemaLength;
    type MaxProofSize = MaxProofSize;
    type MaxIdentityTags = MaxIdentityTags;
    type MaxTagLength = MaxTagLength;
    type MaxPqKeyBytes = MaxPqKeyBytes;
    type WeightInfo = ();
}

#[derive(Clone, Copy, Default)]
pub struct RuntimeSettlementHook;
impl pallet_attestations::SettlementBatchHook<u64, IssuerId, BlockNumber>
    for RuntimeSettlementHook
{
    fn process(events: Vec<AttestationSettlementEvent<u64, IssuerId, BlockNumber>>) {
        for ev in events.into_iter() {
            if ev.stage == pallet_attestations::SettlementStage::RolledBack {
                pallet_settlement::PendingQueue::<Runtime>::mutate(|queue| {
                    queue.retain(|id| id != &ev.commitment_id)
                });
            } else {
                let _ = pallet_settlement::PendingQueue::<Runtime>::try_mutate(|queue| {
                    queue.try_push(ev.commitment_id)
                });
            }
        }
    }
}

impl pallet_attestations::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type CommitmentId = u64;
    type IssuerId = IssuerId;
    type MaxRootSize = MaxRootSize;
    type MaxPendingEvents = MaxPendingEvents;
    type MaxVerificationKeySize = MaxVerificationKeySize;
    type AdminOrigin = frame_system::EnsureRoot<AccountId>;
    type CouncilOrigin = CouncilApprovalOrigin;
    type ReferendaOrigin = ReferendaOrigin;
    type SettlementBatchHook = RuntimeSettlementHook;
    type DefaultVerifierParams = DefaultAttestationVerifierParams;
    type WeightInfo = pallet_attestations::DefaultWeightInfo;
}

parameter_types! {
    pub const MaxPendingPayouts: u32 = 32;
    pub const SettlementValidatorReward: Balance = 10;
}

pub type DefaultRegulatoryTag = pallet_asset_registry::DefaultRegulatoryTag<Runtime>;
pub type DefaultProvenanceRefs = pallet_asset_registry::DefaultProvenanceRefs<Runtime>;

impl pallet_asset_registry::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type AssetId = u32;
    type AttestationId = u32;
    type RoleId = u32;
    type CredentialSchemaId = u32;
    type IdentityTag = pallet_identity::pallet::IdentityTag<Runtime>;
    type Identity = pallet_identity::Pallet<Runtime>;
    type AssetCreatorRole = ConstU32<1>;
    type AssetUpdaterRole = ConstU32<2>;
    type TagManagerRole = ConstU32<3>;
    type ComplianceCredential = ConstU32<99>;
    type MaxMetadataLength = MaxMetadataLength;
    type MaxTagsPerAsset = MaxTagsPerAsset;
    type MaxTagLength = MaxTagLength;
    type MaxProvenanceRefs = MaxProvenanceRefs;
    type WeightInfo = ();
}

parameter_types! {
    pub const MaxLegs: u32 = 8;
    pub const MaxMemo: u32 = 32;
    pub const MaxPendingInstructions: u32 = 16;
    pub const MaxParticipants: u32 = 8;
    pub const MaxNullifiers: u32 = 4;
    pub const MaxSettlementProof: u32 = 128;
    pub const DefaultVerificationKey: u32 = 0;
}

impl pallet_settlement::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type AssetId = u32;
    type Balance = Balance;
    type VerificationKeyId = u32;
    type CouncilOrigin = CouncilApprovalOrigin;
    type ReferendaOrigin = ReferendaOrigin;
    type Currency = Balances;
    type AuthorityId = PqAppCrypto;
    type ProofVerifier = pallet_settlement::StarkVerifier;
    type DefaultVerifierParams = DefaultSettlementVerifierParams;
    type WeightInfo = pallet_settlement::weights::DefaultWeightInfo<Self>;
    type MaxLegs = MaxLegs;
    type MaxMemo = MaxMemo;
    type MaxPendingInstructions = MaxPendingInstructions;
    type MaxParticipants = MaxParticipants;
    type MaxNullifiers = MaxNullifiers;
    type MaxProofSize = MaxSettlementProof;
    type MaxVerificationKeySize = MaxVerificationKeySize;
    type DefaultVerificationKey = DefaultVerificationKey;
    type MaxPendingPayouts = MaxPendingPayouts;
    type ValidatorReward = SettlementValidatorReward;
}

parameter_types! {
    pub const GovernanceRole: u32 = 42;
}

impl pallet_feature_flags::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type GovernanceOrigin = frame_system::EnsureRoot<AccountId>;
    type MaxFeatureNameLength = ConstU32<16>;
    type MaxFeatureCount = ConstU32<16>;
    type MaxCohortSize = ConstU32<32>;
    type WeightInfo = ();
}

impl pallet_observability::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type GovernanceOrigin = frame_system::EnsureRoot<AccountId>;
    type IdentityOrigin = frame_system::EnsureRoot<AccountId>;
    type MaxTrackedActors = ConstU32<16>;
    type WeightInfo = ();
}

parameter_types! {
    pub AttestationWeightCoeff: FixedU128 = FixedU128::from_u32(1);
    pub CredentialWeightCoeff: FixedU128 = FixedU128::from_u32(1);
    pub SettlementWeightCoeff: FixedU128 = FixedU128::from_u32(1);
}

parameter_types! {
    pub const MaxFeeDiscount: u8 = 50;
}

impl pallet_fee_model::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Currency = Balances;
    type IdentityTag = pallet_identity::pallet::IdentityTag<Runtime>;
    type IdentityProvider = RuntimeIdentityProvider;
    type CallClassifier = RuntimeCallClassifier;
    type AttestationWeightCoeff = AttestationWeightCoeff;
    type CredentialWeightCoeff = CredentialWeightCoeff;
    type SettlementWeightCoeff = SettlementWeightCoeff;
    type WeightInfo = pallet_fee_model::weights::SubstrateWeight<Self>;
}

impl pallet_difficulty::Config for Runtime {}

// === Coinbase Configuration ===
parameter_types! {
    /// Maximum subsidy per block (50 HGM = 50 * 10^8 base units)
    /// This is a safety limit - actual subsidy follows halving schedule
    pub const MaxSubsidy: u64 = 50 * 100_000_000;
}

impl pallet_coinbase::Config for Runtime {
    type Currency = Balances;
    type MaxSubsidy = MaxSubsidy;
}

// === Shielded Pool Configuration ===
parameter_types! {
    /// Maximum nullifiers per shielded transaction (inputs).
    pub const MaxNullifiersPerTx: u32 = 4;
    /// Maximum commitments per shielded transaction (outputs).
    pub const MaxCommitmentsPerTx: u32 = 4;
    /// Maximum encrypted notes per transaction.
    pub const MaxEncryptedNotesPerTx: u32 = 4;
    /// Number of historical Merkle roots to keep for anchor validation.
    pub const MerkleRootHistorySize: u32 = 100;
}

impl pallet_shielded_pool::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Currency = Balances;
    type AdminOrigin = frame_system::EnsureRoot<AccountId>;
    type ProofVerifier = pallet_shielded_pool::verifier::StarkVerifier;
    type MaxNullifiersPerTx = MaxNullifiersPerTx;
    type MaxCommitmentsPerTx = MaxCommitmentsPerTx;
    type MaxEncryptedNotesPerTx = MaxEncryptedNotesPerTx;
    type MerkleRootHistorySize = MerkleRootHistorySize;
    type WeightInfo = pallet_shielded_pool::DefaultWeightInfo;
}

construct_runtime!(
    pub enum Runtime {
        System: frame_system::{Pallet, Call, Config<T>, Storage, Event<T>},
        Timestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent},
        Coinbase: pallet_coinbase::{Pallet, Call, Storage, Event<T>, Inherent},
        Pow: pow::{Pallet, Call, Storage, Event<T>},
        Difficulty: pallet_difficulty::{Pallet, Call, Storage, Event<T>, Config<T>},
        Session: pallet_session::{Pallet, Call, Storage, Event<T>, Config<T>},
        Balances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},
        TransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event<T>},
        Sudo: pallet_sudo::{Pallet, Call, Storage, Event<T>, Config<T>},
        Council: pallet_collective::<Instance1>::{Pallet, Call, Storage, Origin<T>, Event<T>},
        CouncilMembership: pallet_membership::<Instance1>::{Pallet, Call, Storage, Event<T>},
        Treasury: pallet_treasury::{Pallet, Call, Storage, Event<T>},
        Oracles: pallet_oracles::{Pallet, Call, Storage, Event<T>},
        Identity: pallet_identity::{Pallet, Call, Storage, Event<T>},
        Attestations: pallet_attestations::{Pallet, Call, Storage, Event<T>},
        AssetRegistry: pallet_asset_registry::{Pallet, Call, Storage, Event<T>},
        Settlement: pallet_settlement::{Pallet, Call, Storage, Event<T>},
        FeatureFlags: pallet_feature_flags::{Pallet, Call, Storage, Event<T>},
        FeeModel: pallet_fee_model::{Pallet, Storage, Event<T>},
        Observability: pallet_observability::{Pallet, Call, Storage, Event<T>},
        ShieldedPool: pallet_shielded_pool::{Pallet, Call, Storage, Event<T>, Config<T>},
    }
);

pub type Currency = Balances;
pub type GovernanceOrigin = frame_system::EnsureRoot<AccountId>;

/// Executive: handles dispatch to the various modules.
pub type Executive = frame_executive::Executive<
    Runtime,
    Block,
    frame_system::ChainContext<Runtime>,
    Runtime,
    AllPalletsWithSystem,
>;

// Re-export pallet_difficulty types for node use
pub use pallet_difficulty::{
    GENESIS_DIFFICULTY, MAX_ADJUSTMENT_FACTOR, MIN_DIFFICULTY, RETARGET_INTERVAL,
    TARGET_BLOCK_TIME_MS,
};

// Note: MaxNullifiersPerTx, MaxCommitmentsPerTx, MaxEncryptedNotesPerTx are
// already defined via parameter_types! above and are accessible from the runtime crate.

sp_api::impl_runtime_apis! {
    impl sp_api::Core<Block> for Runtime {
        fn version() -> sp_version::RuntimeVersion {
            VERSION
        }

        fn execute_block(block: <Block as sp_runtime::traits::Block>::LazyBlock) {
            Executive::execute_block(block);
        }

        fn initialize_block(header: &<Block as sp_runtime::traits::Block>::Header) -> sp_runtime::ExtrinsicInclusionMode {
            Executive::initialize_block(header)
        }
    }

    impl sp_api::Metadata<Block> for Runtime {
        fn metadata() -> sp_core::OpaqueMetadata {
            sp_core::OpaqueMetadata::new(Runtime::metadata().into())
        }

        fn metadata_at_version(version: u32) -> Option<sp_core::OpaqueMetadata> {
            Runtime::metadata_at_version(version)
        }

        fn metadata_versions() -> sp_std::vec::Vec<u32> {
            Runtime::metadata_versions()
        }
    }

    impl sp_block_builder::BlockBuilder<Block> for Runtime {
        fn apply_extrinsic(extrinsic: <Block as sp_runtime::traits::Block>::Extrinsic) -> sp_runtime::ApplyExtrinsicResult {
            Executive::apply_extrinsic(extrinsic)
        }

        fn finalize_block() -> <Block as sp_runtime::traits::Block>::Header {
            Executive::finalize_block()
        }

        fn inherent_extrinsics(data: sp_inherents::InherentData) -> Vec<<Block as sp_runtime::traits::Block>::Extrinsic> {
            data.create_extrinsics()
        }

        fn check_inherents(
            block: <Block as sp_runtime::traits::Block>::LazyBlock,
            data: sp_inherents::InherentData,
        ) -> sp_inherents::CheckInherentsResult {
            data.check_extrinsics(&block)
        }
    }

    impl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {
        fn validate_transaction(
            source: sp_runtime::transaction_validity::TransactionSource,
            tx: <Block as sp_runtime::traits::Block>::Extrinsic,
            block_hash: <Block as sp_runtime::traits::Block>::Hash,
        ) -> sp_runtime::transaction_validity::TransactionValidity {
            Executive::validate_transaction(source, tx, block_hash)
        }
    }

    impl sp_offchain::OffchainWorkerApi<Block> for Runtime {
        fn offchain_worker(header: &<Block as sp_runtime::traits::Block>::Header) {
            Executive::offchain_worker(header)
        }
    }

    impl sp_session::SessionKeys<Block> for Runtime {
        fn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {
            DummySessionKeys::generate(seed)
        }

        fn decode_session_keys(encoded: Vec<u8>) -> Option<Vec<(Vec<u8>, sp_core::crypto::KeyTypeId)>> {
            DummySessionKeys::decode_into_raw_public_keys(&encoded)
        }
    }

    impl sp_genesis_builder::GenesisBuilder<Block> for Runtime {
        fn build_state(config: Vec<u8>) -> sp_genesis_builder::Result {
            frame_support::genesis_builder_helper::build_state::<RuntimeGenesisConfig>(config)
        }

        fn get_preset(id: &Option<sp_genesis_builder::PresetId>) -> Option<Vec<u8>> {
            frame_support::genesis_builder_helper::get_preset::<RuntimeGenesisConfig>(id, |_| None)
        }

        fn preset_names() -> Vec<sp_genesis_builder::PresetId> {
            Vec::new()
        }
    }

    // ============ HEGEMON CUSTOM APIs ============

    impl apis::DifficultyApi<Block> for Runtime {
        fn difficulty() -> sp_core::U256 {
            Difficulty::difficulty()
        }
    }

    impl apis::ConsensusApi<Block> for Runtime {
        fn target_block_time() -> u64 {
            pallet_difficulty::TARGET_BLOCK_TIME_MS
        }

        fn blocks_until_retarget() -> u32 {
            Difficulty::blocks_until_retarget()
        }

        fn difficulty_bits() -> u32 {
            Difficulty::difficulty_bits()
        }
    }

    impl apis::ShieldedPoolApi<Block> for Runtime {
        fn get_encrypted_notes(
            start: u64,
            limit: u32,
        ) -> sp_std::vec::Vec<(u64, sp_std::vec::Vec<u8>, u64, [u8; 32])> {
            // Fetch encrypted notes from ShieldedPool pallet storage
            let mut notes = sp_std::vec::Vec::new();
            let end = start.saturating_add(limit as u64);
            
            for index in start..end {
                if let Some(encrypted_note) = pallet_shielded_pool::EncryptedNotes::<Runtime>::get(index) {
                    if let Some(commitment) = pallet_shielded_pool::Commitments::<Runtime>::get(index) {
                        // Block height not tracked per-note, use current block
                        let block = frame_system::Pallet::<Runtime>::block_number();
                        notes.push((
                            index,
                            encrypted_note.ciphertext.to_vec(),
                            block.into(),
                            commitment,
                        ));
                    }
                }
            }
            notes
        }

        fn encrypted_note_count() -> u64 {
            pallet_shielded_pool::CommitmentIndex::<Runtime>::get()
        }

        fn get_merkle_witness(
            position: u64,
        ) -> Result<(sp_std::vec::Vec<[u8; 32]>, sp_std::vec::Vec<bool>, [u8; 32]), ()> {
            // Get the Merkle tree from storage
            let tree = pallet_shielded_pool::MerkleTree::<Runtime>::get();
            
            // CompactMerkleTree stores frontier only, not full witness data.
            // For now, return a witness using the frontier.
            // A full implementation would reconstruct from stored leaves.
            let root = tree.root();
            let depth = pallet_shielded_pool::types::MERKLE_TREE_DEPTH;
            
            // Check position is valid
            if position >= tree.len() {
                return Err(());
            }
            
            // Generate authentication path from frontier
            // This is simplified - a full impl would store more intermediate nodes
            let defaults = pallet_shielded_pool::merkle::DefaultHashes::new(depth);
            let mut siblings = sp_std::vec::Vec::with_capacity(depth as usize);
            let mut indices = sp_std::vec::Vec::with_capacity(depth as usize);
            
            let mut level_position = position;
            for level in 0..depth {
                let is_left = level_position & 1 == 0;
                let sibling_position = level_position ^ 1;
                
                // Get sibling from frontier if available, otherwise use default
                let sibling = if (level as usize) < tree.frontier.len() 
                    && sibling_position * (1u64 << level) < tree.len() 
                {
                    tree.frontier[level as usize]
                } else {
                    defaults.at_level(level)
                };
                
                siblings.push(sibling);
                indices.push(!is_left); // true if we're the right child
                
                level_position >>= 1;
            }
            
            Ok((siblings, indices, root))
        }

        fn is_nullifier_spent(nullifier: [u8; 32]) -> bool {
            pallet_shielded_pool::Nullifiers::<Runtime>::contains_key(nullifier)
        }

        fn is_valid_anchor(anchor: [u8; 32]) -> bool {
            pallet_shielded_pool::MerkleRoots::<Runtime>::contains_key(anchor)
        }

        fn pool_balance() -> u128 {
            pallet_shielded_pool::PoolBalance::<Runtime>::get()
        }

        fn merkle_root() -> [u8; 32] {
            pallet_shielded_pool::MerkleTree::<Runtime>::get().root()
        }

        fn tree_depth() -> u32 {
            pallet_shielded_pool::types::MERKLE_TREE_DEPTH
        }

        fn nullifier_count() -> u64 {
            // Count nullifiers in storage
            pallet_shielded_pool::Nullifiers::<Runtime>::iter().count() as u64
        }
    }
}

// Task 11.4.1: RuntimeApi Export Documentation
//
// The `impl_runtime_apis!` macro above generates a `pub struct RuntimeApi {}`
// that implements `ConstructRuntimeApi<Block, C>` for the node to use when
// creating the full Substrate client:
//
// ```rust
// sc_service::new_full_parts::<runtime::Block, runtime::RuntimeApi, _>(...)
// ```
//
// The RuntimeApi struct is automatically public and available for import by
// the node crate. No explicit re-export is needed since the macro already
// declares it as `pub struct RuntimeApi {}`.
//
// The node should import it as:
// ```rust
// use runtime::RuntimeApi;
// ```

#[cfg(all(test, feature = "runtime-tests"))]
mod tests {
    use super::*;
    use frame_support::assert_noop;
    use frame_support::pallet_prelude::Zero;
    use frame_support::{
        assert_ok,
        traits::{Hooks, StorageVersion},
        BoundedVec,
    };
    use sp_core::U256;
    use sp_runtime::BuildStorage;

    fn account(seed: u8) -> AccountId {
        AccountId::from([seed; 32])
    }

    fn compact_to_target(bits: u32) -> Option<U256> {
        let exponent = bits >> 24;
        let mantissa = bits & 0x00ff_ffff;
        if mantissa == 0 {
            return None;
        }
        if exponent > 32 {
            return Some(U256::MAX);
        }
        let mut target = U256::from(mantissa);
        if exponent > 3 {
            let shift = 8 * (exponent - 3) as usize;
            target = target.checked_mul(U256::from(1u8) << shift)?;
        } else {
            target >>= 8 * (3 - exponent);
        }
        Some(target)
    }

    fn seal_meets_target(pre_hash: H256, nonce: u64, pow_bits: u32) -> bool {
        let mut data = pre_hash.as_bytes().to_vec();
        data.extend_from_slice(&nonce.to_le_bytes());
        let hash = sp_io::hashing::blake2_256(&data);
        let hash_u256 = U256::from_big_endian(&hash);
        if let Some(target) = compact_to_target(pow_bits) {
            hash_u256 <= target
        } else {
            false
        }
    }

    fn valid_nonce(pre_hash: H256, pow_bits: u32) -> u64 {
        (0u64..)
            .find(|candidate| seal_meets_target(pre_hash, *candidate, pow_bits))
            .expect("nonce available for easy difficulty")
    }

    fn new_ext() -> sp_io::TestExternalities {
        let mut t = frame_system::GenesisConfig::<Runtime>::default()
            .build_storage()
            .unwrap();
        pallet_balances::GenesisConfig::<Runtime> {
            balances: vec![(account(1), 1_000_000), (account(2), 1_000_000)],
            dev_accounts: None,
        }
        .assimilate_storage(&mut t)
        .unwrap();
        t.into()
    }

    #[test]
    fn pow_block_imports_with_valid_seal() {
        new_ext().execute_with(|| {
            System::set_block_number(1);
            Timestamp::set_timestamp(0);
            let pow_bits = PowDifficulty::get();
            let pre_hash = H256::repeat_byte(7);
            let nonce = valid_nonce(pre_hash, pow_bits);

            assert_ok!(Pow::submit_work(
                RuntimeOrigin::signed(account(1)),
                pre_hash,
                nonce,
                pow_bits,
                0,
            ));

            let events = System::events();
            assert!(events.iter().any(|evt| matches!(
                evt.event,
                RuntimeEvent::Pow(pow::Event::PowBlockImported { pow_bits: b, nonce: n, .. }) if b == pow_bits && n == nonce
            )));
            assert_eq!(pow::Difficulty::<Runtime>::get(), pow_bits);
        });
    }

    #[test]
    fn pow_rejects_invalid_seal() {
        new_ext().execute_with(|| {
            System::set_block_number(1);
            Timestamp::set_timestamp(0);
            let pow_bits = PowDifficulty::get();
            let pre_hash = H256::repeat_byte(9);
            let bad_nonce = (0u64..)
                .find(|candidate| !seal_meets_target(pre_hash, *candidate, pow_bits))
                .expect("non-matching nonce exists");

            assert_noop!(
                Pow::submit_work(
                    RuntimeOrigin::signed(account(1)),
                    pre_hash,
                    bad_nonce,
                    pow_bits,
                    0
                ),
                pow::Error::<Runtime>::InsufficientWork
            );

            let events = System::events();
            assert!(events.iter().any(|evt| matches!(
                evt.event,
                RuntimeEvent::Pow(pow::Event::PowInvalidSeal { nonce, .. }) if nonce == bad_nonce
            )));
        });
    }

    #[test]
    fn session_rotation_emits_pow_validator_set() {
        new_ext().execute_with(|| {
            System::set_block_number(1);
            Timestamp::set_timestamp(0);
            let pow_bits = PowDifficulty::get();
            let pre_hash = H256::repeat_byte(1);
            let nonce = valid_nonce(pre_hash, pow_bits);
            assert_ok!(Pow::submit_work(
                RuntimeOrigin::signed(account(1)),
                pre_hash,
                nonce,
                pow_bits,
                0,
            ));

            let pre_hash_two = H256::repeat_byte(2);
            let nonce_two = valid_nonce(pre_hash_two, pow_bits);
            System::set_block_number(SessionPeriod::get());
            Timestamp::set_timestamp(PowTargetBlockTime::get());
            assert_ok!(Pow::submit_work(
                RuntimeOrigin::signed(account(2)),
                pre_hash_two,
                nonce_two,
                pow_bits,
                PowTargetBlockTime::get(),
            ));

            for n in 1..=SessionPeriod::get() + 1 {
                Session::on_initialize(n);
            }

            let events = System::events();
            assert!(events.iter().any(|evt| matches!(
                evt.event,
                RuntimeEvent::Pow(pow::Event::SessionValidatorsRotated { ref validators, .. })
                    if validators.contains(&account(1)) && validators.contains(&account(2))
            )));
        });
    }

    #[test]
    fn identity_hooks_enqueue_attestations_and_settlement() {
        new_ext().execute_with(|| {
            System::set_block_number(1);
            let schema = 7u32;
            let schema_bytes: BoundedVec<u8, MaxSchemaLength> =
                BoundedVec::try_from(vec![1u8]).unwrap();
            assert_ok!(Identity::store_schema(
                RuntimeOrigin::root(),
                schema,
                schema_bytes.clone().into_inner(),
                false
            ));
            let payload = schema.to_le_bytes().to_vec();
            assert_ok!(Identity::issue_credential(
                RuntimeOrigin::signed(account(1)),
                schema,
                account(2),
                None,
                payload,
                vec![]
            ));

            Attestations::offchain_worker(1);

            let pending = pallet_attestations::PendingSettlementEvents::<Runtime>::get();
            assert_eq!(pending.len(), 0); // consumed by offchain worker
            let queue = pallet_settlement::PendingQueue::<Runtime>::get();
            assert!(queue.contains(&(schema as u64)));
        });
    }

    #[test]
    fn revocation_clears_pending_queues() {
        new_ext().execute_with(|| {
            System::set_block_number(1);
            let schema = 9u32;
            let schema_bytes: BoundedVec<u8, MaxSchemaLength> =
                BoundedVec::try_from(vec![1u8]).unwrap();
            assert_ok!(Identity::store_schema(
                RuntimeOrigin::root(),
                schema,
                schema_bytes.clone().into_inner(),
                false
            ));
            let payload = schema.to_le_bytes().to_vec();
            assert_ok!(Identity::issue_credential(
                RuntimeOrigin::signed(account(1)),
                schema,
                account(2),
                None,
                payload,
                vec![]
            ));
            Attestations::offchain_worker(1);
            assert!(pallet_settlement::PendingQueue::<Runtime>::get().contains(&(schema as u64)));

            assert_ok!(Identity::revoke_credential(
                RuntimeOrigin::signed(account(1)),
                schema,
                account(2)
            ));
            Attestations::offchain_worker(2);
            assert!(!pallet_settlement::PendingQueue::<Runtime>::get().contains(&(schema as u64)));
        });
    }

    #[test]
    fn pallet_migrations_bump_storage_versions() {
        new_ext().execute_with(|| {
            StorageVersion::new(0).put::<pallet_feature_flags::Pallet<Runtime>>();
            StorageVersion::new(0).put::<pallet_asset_registry::Pallet<Runtime>>();
            StorageVersion::new(0).put::<pallet_identity::Pallet<Runtime>>();
            StorageVersion::new(0).put::<pallet_attestations::Pallet<Runtime>>();
            StorageVersion::new(0).put::<pallet_oracles::Pallet<Runtime>>();
            StorageVersion::new(0).put::<pallet_settlement::Pallet<Runtime>>();
            StorageVersion::new(0).put::<pallet_observability::Pallet<Runtime>>();

            let feature_weight = pallet_feature_flags::Pallet::<Runtime>::on_runtime_upgrade();
            assert_eq!(
                StorageVersion::get::<pallet_feature_flags::Pallet<Runtime>>(),
                pallet_feature_flags::pallet::STORAGE_VERSION
            );
            assert!(!feature_weight.is_zero());

            let asset_weight = pallet_asset_registry::Pallet::<Runtime>::on_runtime_upgrade();
            assert_eq!(
                StorageVersion::get::<pallet_asset_registry::Pallet<Runtime>>(),
                pallet_asset_registry::pallet::STORAGE_VERSION
            );
            assert!(!asset_weight.is_zero());

            let identity_weight = pallet_identity::Pallet::<Runtime>::on_runtime_upgrade();
            assert_eq!(
                StorageVersion::get::<pallet_identity::Pallet<Runtime>>(),
                pallet_identity::pallet::STORAGE_VERSION
            );
            assert!(!identity_weight.is_zero());

            let attestations_weight = pallet_attestations::Pallet::<Runtime>::on_runtime_upgrade();
            assert_eq!(
                StorageVersion::get::<pallet_attestations::Pallet<Runtime>>(),
                pallet_attestations::pallet::STORAGE_VERSION
            );
            assert!(!attestations_weight.is_zero());

            let oracle_weight = pallet_oracles::Pallet::<Runtime>::on_runtime_upgrade();
            assert_eq!(
                StorageVersion::get::<pallet_oracles::Pallet<Runtime>>(),
                pallet_oracles::pallet::STORAGE_VERSION
            );
            assert!(!oracle_weight.is_zero());

            let settlement_weight = pallet_settlement::Pallet::<Runtime>::on_runtime_upgrade();
            assert_eq!(
                StorageVersion::get::<pallet_settlement::Pallet<Runtime>>(),
                pallet_settlement::STORAGE_VERSION
            );
            assert!(!settlement_weight.is_zero());

            let observability_weight =
                pallet_observability::Pallet::<Runtime>::on_runtime_upgrade();
            assert_eq!(
                StorageVersion::get::<pallet_observability::Pallet<Runtime>>(),
                pallet_observability::pallet::STORAGE_VERSION
            );
            assert!(!observability_weight.is_zero());
        });
    }
}
