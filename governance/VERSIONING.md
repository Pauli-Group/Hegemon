# Version governance and activation playbook

This document supplements DESIGN.md / METHODS.md by describing how we use the new version identifiers in code (`protocol-versioning`) and the governance structures (`VersionProposal`, `VersionSchedule`, `UpgradeDirective`) to roll out or retire primitives without splitting the privacy pool. The guidance below assumes Proof-of-Work block production: “operators” are miners, mining pool maintainers, or full node operators who distribute binaries to them.

## Terminology

- **VersionBinding** – a `(circuit_version, crypto_suite)` pair compiled into every transaction witness/proof.
- **VersionCommitment** – a SHA-256 hash of the per-block version matrix, published in every block header so peers know exactly which bindings were accepted.
- **VersionSchedule** – a consensus-side structure that records which bindings are valid at which heights. It is populated with `VersionProposal`s.
- **VersionProposal** – the ZIP-style governance artifact that specifies:
  - the `VersionBinding` being activated,
  - `activates_at` (height when miners/validators must accept the binding),
  - optional `retires_at` (height after which the binding is rejected),
  - optional `UpgradeDirective` (the binding for the migration/upgrade circuit plus the height at which that circuit becomes mandatory).

## Proposal lifecycle

1. **Draft** – Authors describe the change, security motivation, and expected activation/retirement heights. They attach new verifying/proving keys for the target binding and (if applicable) the upgrade circuit binding. Proposed `activates_at` / `retires_at` heights must fall on the mandatory activation checkpoints encoded in `VersionSchedule` semantics so miners can deterministically enforce them without a coordination side channel.
2. **Review** – Engineering / security teams run regression tests (see `tests/block_flow.rs::mixed_versions_require_declared_keys`) with the proposed bindings to ensure mixed-version blocks still verify. The `governance/VERSIONING.md` document is updated with rationale and parameters.
3. **Scheduling** – Once ratified, the proposal is added to `VersionSchedule` by calling `register(VersionProposal { ... })`. This step bakes the activation height into consensus: every PoW node computes the same `VersionSchedule` state at a given height, so block templates generated by miners after `activates_at` must include the new binding. The activation height is announced at least 2 epochs ahead so wallets can ship new proving keys and pools can propagate updated binaries.
4. **Activation** – At `activates_at`, miners and pool operators must redeploy binaries that include the new verifying key(s) and `VersionSchedule` snapshot. When a miner connects to its template source, the node compares the locally cached bindings against `VersionSchedule::first_unsupported(height)`; any template that omits a now-mandatory binding is invalid and should be rejected before hashing. Full nodes use the same check to reject blocks from lagging miners with `ConsensusError::UnsupportedVersion`.
5. **Monitoring** – During the grace period between `activates_at` and `retires_at`, operators watch the `version_counts` reported by recursive block proofs and `version_commitment` in headers to ensure usage trends as expected. Mining pools should mirror those metrics in their dashboards and alarm if old bindings persist beyond the planned decay curve.
6. **Retirement** – At `retires_at`, the binding is removed from `VersionSchedule` and therefore from the consensus-accepted binding matrix. Miners must delete the obsolete verifying key from their key-store bundles to avoid producing blocks with unsupported witnesses; full nodes will reject any straggler proofs at consensus level even if they would otherwise verify.

## How miners learn about new bindings

The network intentionally mirrors soft-fork activation habits from Bitcoin-style deployments:

1. **Governance artifact distribution** – Every ratified `VersionProposal` (plus attached verifying key digests) is published in the governance repository and mirrored as a signed bulletin sent to mining pools and infrastructure providers. Pools treat this similarly to a template change announcement.
2. **Mandatory activation checkpoints** – `VersionSchedule` exposes deterministic checkpoints; once a proposal is registered, its heights become part of the consensus rules. Nodes persist the schedule locally and ship its hash in release notes so miners can confirm they are on the canonical branch.
3. **Template enforcement** – Mining nodes that construct block templates recompute `VersionSchedule` at the candidate height and ensure the per-template `version_matrix` includes every binding returned by `VersionSchedule::bindings_for_height(height)`. No explicit signaling bits are required—new bindings become mandatory exactly at the encoded height. Optional signaling (e.g., dashboard toggles) may still be used to visualize readiness, but consensus enforcement does not depend on it.
4. **Conflict handling** – If two proposals attempt to occupy the same height with incompatible bindings, governance merges them into a linearized schedule before `register` is called. On-chain enforcement therefore cannot observe the conflict; nodes always see one deterministic binding set per height. Should a miner somehow compile an outdated `VersionSchedule`, full nodes reject their blocks with `ConsensusError::UnsupportedVersion`, and pools drop the miner until they upgrade.

## Updating verifying keys

Miners never derive verifying keys themselves; they pull signed bundles provided alongside each `VersionProposal`. The rollout steps are:

1. Governance publishes the proving/verifying key artifacts (or URIs + SHA-256 digests) referenced in the proposal.
2. Mining pools fetch the bundle, verify the digests against the proposal, and repack the keys into their preferred deployment format (e.g., Docker layers or immutable object storage).
3. Operators stage the new keys on their template-serving full nodes. When the node process restarts, it loads the updated key map and `VersionSchedule` snapshot.
4. Individual miners that run their own full nodes repeat the same process or subscribe to the pool’s binary distribution channel.

If a miner produces a block referencing a binding whose verifying key hash does not match the canonical bundle, the block fails verification at peers. Because `version_commitment` includes the exact binding map hash, conflicting deployments are easy to detect: monitoring compares the published `VersionProposal` hash to the observed commitments. Governance artifacts (signed Markdown + JSON attachments) are disseminated through the repository, the operations mailing list, and an IPFS mirror so geographically distributed pools receive them quickly.

## Upgrade circuits and note migration

When a primitive needs to be replaced (e.g., moving from ML-KEM-768 to a post-attack variant), proposals should include an `UpgradeDirective`:

- `from` – the binding being deprecated.
- `to` – the new binding the ecosystem should move toward.
- `circuit` – the binding of the special upgrade circuit that proves "I owned a note under `from` and recreated it under `to`".
- `activation_height` – when the upgrade circuit must be accepted (usually the same as the new binding’s activation).

The upgrade circuit lives alongside normal transaction circuits. Wallets craft an "upgrade transaction" that consumes the old note, outputs an equivalent note under the new binding, and pays any mandated migration fee. Consensus treats the upgrade circuit like any other binding, so it benefits from the same `version_commitment`/`version_counts` monitoring. Mining templates must therefore include the upgrade binding as soon as `VersionSchedule::bindings_for_height` lists it, and pools should surface the relative share of upgrade proofs when assessing progress.

## Emergency primitive swap runbook (summary)

A detailed operator checklist lives in `runbooks/emergency_version_swap.md`, but the key actions are:

1. Detect the issue and draft a VersionProposal + UpgradeDirective with aggressive activation/retirement heights.
2. Push the proposal through review/governance and merge the new bindings/keys.
3. Publish the activation plan to miners, mining pool operators, and wallet maintainers (validators follow the same instructions if present, but PoW operators are the first-class audience).
4. Update `VersionSchedule` on every template-serving node, redeploy verifying-key maps to miners, and start accepting the upgrade circuit binding in block templates.
5. Track `version_counts` to ensure the old binding winds down before `retires_at`, mirroring the data to pool dashboards so individual miners see the migration curve.
6. After retirement, remove the old verifying key from block producers/miners to avoid accidental acceptance.
